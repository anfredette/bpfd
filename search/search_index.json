{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"bpfd is a system daemon aimed at simplifying the deployment and management of eBPF programs. It's goal is to enhance the developer-experience as well as provide features to improve security, visibility and program-cooperation. bpfd includes a Kubernetes operator to bring those same features to Kubernetes, allowing users to safely deploy eBPF via custom resources across nodes in a cluster. Why eBPF? eBPF is a powerful general-purpose framework that allows running sandboxed programs in the kernel. It can be used for many purposes, including networking, monitoring, tracing and security. Why eBPF in Kubernetes? Demand is increasing from both Kubernetes developers and users. Examples of eBPF in Kubernetes include: Cilium Calico CNIs Pixie : Open source observability KubeArmor : Container-aware runtime security enforcement system Blixt : Gateway API L4 conformance implementation NetObserv : Open source operator for network observability Challenges for eBPF in Kubernetes Requires privileged pods. eBPF-enabled apps require at least CAP_BPF permissions and potentially more depending on the type of program that is being attached. Since the Linux capabilities are very broad it is challenging to constrain a pod to the minimum set of privileges required. This can allow them to do damage (either unintentionally or intentionally). Handling multiple eBPF programs on the same eBPF hooks. Not all eBPF hooks are designed to support multiple programs. Some software using eBPF assumes exclusive use of a eBPF hook and can unintentionally eject existing programs when being attached. This can result in silent failures and non-deterministic failures. Debugging problems with deployments is hard. The cluster administrator may not be aware that eBPF programs are being used in a cluster. It is possible for some eBPF programs to interfere with others in unpredictable ways. SSH access or a privileged pod is necessary to determine the state of eBPF programs on each node in the cluster. Lifecycle management of eBPF programs. While there are libraries for the basic loading and unloading of eBPF programs, a lot of code is often needed around them for lifecycle management. Deployment on Kubernetes is not simple. It is an involved process that requires first writing a daemon that loads your eBPF bytecode and deploying it using a DaemonSet. This requires careful design and intricate knowledge of the eBPF program lifecycle to ensure your program stays loaded and that you can easily tolerate pod restarts and upgrades. In eBPF enabled K8s deployments today, the eBPF Program is often embedded into the userspace binary that loads and interacts with it. This means there's no easy way to have fine-grained versioning control of the bpfProgram in relation to it's accompanying userspace counterpart. What is bpfd? bpfd is a software stack that aims to make it easy to load, unload, modify and monitor eBPF programs whether on a single host, or in a Kubernetes cluster. bpfd includes the following core components: bpfd: A system daemon that supports loading, unloading, modifying and monitoring of eBPF programs exposed over a gRPC API. eBPF CRDS: bpfd provides a set of CRDs ( XdpProgram , TcProgram , etc.) that provide a way to express intent to load eBPF programs as well as a bpfd generated CRD ( BpfProgram ) used to represent the runtime state of loaded programs. bpfd-agent: The agent runs in a container in the bpfd daemonset and ensures that the requested eBPF programs for a given node are in the desired state. bpfd-operator: An operator, built using Operator SDK , that manages the installation and lifecycle of bpfd-agent and the CRDs in a Kubernetes cluster. bpfd is developed in Rust and built on top of Aya, a Rust eBPF library. The benefits of this solution include the following: Security Improved security because only the bpfd daemon, which can be tightly controlled, has the privileges needed to load eBPF programs, while access to the API can be controlled via standard RBAC methods. Within bpfd, only a single thread keeps these capabilities while the other threads (serving RPCs) do not. Gives the administrators control over who can load programs. Allows administrators to define rules for the ordering of networking eBPF programs. (ROADMAP) Visibility/Debuggability Improved visibility into what eBPF programs are running on a system, which enhances the debuggability for developers, administrators, and customer support. The greatest benefit is achieved when all apps use bpfd, but even if they don't, bpfd can provide visibility into all the eBPF programs loaded on the nodes in a cluster. Multi-program Support Support for the coexistence of multiple eBPF programs from multiple users. Uses the libxdp multiprog protocol to allow multiple XDP programs on single interface This same protocol is also supported for TC programs to provide a common multi-program user experience across both TC and XDP. Productivity Simplifies the deployment and lifecycle management of eBPF programs in a Kubernetes cluster. developers can stop worrying about program lifecycle (loading, attaching, pin management, etc.) and use existing eBPF libraries to interact with their program maps using well defined pin points which are managed by bpfd. Developers can still use Cilium/libbpf/Aya/etc libraries for eBPF development, and load/unload with bpfd. Provides eBPF Bytecode Image Specifications that allows fine-grained separate versioning control for userspace and kernelspace programs. This also allows for signing these container images to verify bytecode ownership. For more details, please see the following: Setup and Building bpfd for instructions on setting up your development environment and building bpfd. Tutorial for some examples of starting bpfd , managing logs, and using bpfctl . Example eBPF Programs for some examples of eBPF programs written in Go, interacting with bpfd . Deploying the bpfd-operator for details on launching bpfd in a Kubernetes cluster. Meet the Community for details on community meeting details. License bpf Code in this crate is distributed under the terms of the GNU General Public License, Version 2 or the BSD 2 Clause license, at your option. Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in this crate by you, as defined in the GPL-2 license, shall be dual licensed as above, without any additional terms or conditions. bpfd, bpfd-common Rust code in all other crates is distributed under the terms of either the MIT license or the Apache License (version 2.0), at your option. Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in this crate by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions. The bpfd crate also contains eBPF code that is distributed under the terms of the GNU General Public License, Version 2 or the BSD 2 Clause license, at your option. It is packaged, in object form, inside the bpfd binary.","title":"Introduction"},{"location":"#_1","text":"bpfd is a system daemon aimed at simplifying the deployment and management of eBPF programs. It's goal is to enhance the developer-experience as well as provide features to improve security, visibility and program-cooperation. bpfd includes a Kubernetes operator to bring those same features to Kubernetes, allowing users to safely deploy eBPF via custom resources across nodes in a cluster.","title":""},{"location":"#why-ebpf","text":"eBPF is a powerful general-purpose framework that allows running sandboxed programs in the kernel. It can be used for many purposes, including networking, monitoring, tracing and security.","title":"Why eBPF?"},{"location":"#why-ebpf-in-kubernetes","text":"Demand is increasing from both Kubernetes developers and users. Examples of eBPF in Kubernetes include: Cilium Calico CNIs Pixie : Open source observability KubeArmor : Container-aware runtime security enforcement system Blixt : Gateway API L4 conformance implementation NetObserv : Open source operator for network observability","title":"Why eBPF in Kubernetes?"},{"location":"#challenges-for-ebpf-in-kubernetes","text":"Requires privileged pods. eBPF-enabled apps require at least CAP_BPF permissions and potentially more depending on the type of program that is being attached. Since the Linux capabilities are very broad it is challenging to constrain a pod to the minimum set of privileges required. This can allow them to do damage (either unintentionally or intentionally). Handling multiple eBPF programs on the same eBPF hooks. Not all eBPF hooks are designed to support multiple programs. Some software using eBPF assumes exclusive use of a eBPF hook and can unintentionally eject existing programs when being attached. This can result in silent failures and non-deterministic failures. Debugging problems with deployments is hard. The cluster administrator may not be aware that eBPF programs are being used in a cluster. It is possible for some eBPF programs to interfere with others in unpredictable ways. SSH access or a privileged pod is necessary to determine the state of eBPF programs on each node in the cluster. Lifecycle management of eBPF programs. While there are libraries for the basic loading and unloading of eBPF programs, a lot of code is often needed around them for lifecycle management. Deployment on Kubernetes is not simple. It is an involved process that requires first writing a daemon that loads your eBPF bytecode and deploying it using a DaemonSet. This requires careful design and intricate knowledge of the eBPF program lifecycle to ensure your program stays loaded and that you can easily tolerate pod restarts and upgrades. In eBPF enabled K8s deployments today, the eBPF Program is often embedded into the userspace binary that loads and interacts with it. This means there's no easy way to have fine-grained versioning control of the bpfProgram in relation to it's accompanying userspace counterpart.","title":"Challenges for eBPF in Kubernetes"},{"location":"#what-is-bpfd","text":"bpfd is a software stack that aims to make it easy to load, unload, modify and monitor eBPF programs whether on a single host, or in a Kubernetes cluster. bpfd includes the following core components: bpfd: A system daemon that supports loading, unloading, modifying and monitoring of eBPF programs exposed over a gRPC API. eBPF CRDS: bpfd provides a set of CRDs ( XdpProgram , TcProgram , etc.) that provide a way to express intent to load eBPF programs as well as a bpfd generated CRD ( BpfProgram ) used to represent the runtime state of loaded programs. bpfd-agent: The agent runs in a container in the bpfd daemonset and ensures that the requested eBPF programs for a given node are in the desired state. bpfd-operator: An operator, built using Operator SDK , that manages the installation and lifecycle of bpfd-agent and the CRDs in a Kubernetes cluster. bpfd is developed in Rust and built on top of Aya, a Rust eBPF library. The benefits of this solution include the following: Security Improved security because only the bpfd daemon, which can be tightly controlled, has the privileges needed to load eBPF programs, while access to the API can be controlled via standard RBAC methods. Within bpfd, only a single thread keeps these capabilities while the other threads (serving RPCs) do not. Gives the administrators control over who can load programs. Allows administrators to define rules for the ordering of networking eBPF programs. (ROADMAP) Visibility/Debuggability Improved visibility into what eBPF programs are running on a system, which enhances the debuggability for developers, administrators, and customer support. The greatest benefit is achieved when all apps use bpfd, but even if they don't, bpfd can provide visibility into all the eBPF programs loaded on the nodes in a cluster. Multi-program Support Support for the coexistence of multiple eBPF programs from multiple users. Uses the libxdp multiprog protocol to allow multiple XDP programs on single interface This same protocol is also supported for TC programs to provide a common multi-program user experience across both TC and XDP. Productivity Simplifies the deployment and lifecycle management of eBPF programs in a Kubernetes cluster. developers can stop worrying about program lifecycle (loading, attaching, pin management, etc.) and use existing eBPF libraries to interact with their program maps using well defined pin points which are managed by bpfd. Developers can still use Cilium/libbpf/Aya/etc libraries for eBPF development, and load/unload with bpfd. Provides eBPF Bytecode Image Specifications that allows fine-grained separate versioning control for userspace and kernelspace programs. This also allows for signing these container images to verify bytecode ownership. For more details, please see the following: Setup and Building bpfd for instructions on setting up your development environment and building bpfd. Tutorial for some examples of starting bpfd , managing logs, and using bpfctl . Example eBPF Programs for some examples of eBPF programs written in Go, interacting with bpfd . Deploying the bpfd-operator for details on launching bpfd in a Kubernetes cluster. Meet the Community for details on community meeting details.","title":"What is bpfd?"},{"location":"#license","text":"","title":"License"},{"location":"#bpf","text":"Code in this crate is distributed under the terms of the GNU General Public License, Version 2 or the BSD 2 Clause license, at your option. Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in this crate by you, as defined in the GPL-2 license, shall be dual licensed as above, without any additional terms or conditions.","title":"bpf"},{"location":"#bpfd-bpfd-common","text":"Rust code in all other crates is distributed under the terms of either the MIT license or the Apache License (version 2.0), at your option. Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in this crate by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions. The bpfd crate also contains eBPF code that is distributed under the terms of the GNU General Public License, Version 2 or the BSD 2 Clause license, at your option. It is packaged, in object form, inside the bpfd binary.","title":"bpfd, bpfd-common"},{"location":"developer-guide/api-spec/","text":"API Specification REPLACE_WITH_GENERATED_CONTENT","title":"Kubernetes CRD API-Reference"},{"location":"developer-guide/api-spec/#api-specification","text":"REPLACE_WITH_GENERATED_CONTENT","title":"API Specification"},{"location":"developer-guide/configuration/","text":"Configuration bpfd Configuration File bpfd looks for a configuration file to be present at /etc/bpfd/bpfd.toml . If no file is found, defaults are assumed. There is an example at scripts/bpfd.toml , similar to: [ tls ] # REQUIRED ca_cert = \"/etc/bpfd/certs/ca/ca.pem\" cert = \"/etc/bpfd/certs/bpfd/bpfd.pem\" key = \"/etc/bpfd/certs/bpfd/bpfd.key\" client_cert = \"/etc/bpfd/certs/bpfd-client/bpfd-client.pem\" client_key = \"/etc/bpfd/certs/bpfd-client/bpfd-client.key\" [interfaces] [interface.eth0] xdp_mode = \"hw\" # Valid xdp modes are \"hw\", \"skb\" and \"drv\". Default: \"skb\". [[grpc.endpoints]] type = \"tcp\" enabled = true address = \"::1\" port = 50051 [[grpc.endpoints]] type = \"unix\" enabled = false path = \"/run/bpfd/bpfd.sock\" bpfctl and bpfd-agent (which is only used in Kubernetes type deployments) will also read the bpfd configuration file ( /etc/bpfd/bpfd.toml ) to retrieve the bpfd-client certificate file locations. Config Section: [tls] This section of the configuration file allows the mTLS certificate authority file locations to be overwritten. If the given certificates exist, then bpfd will use them. Otherwise, bpfd will create them. Default values are shown above. Valid fields: ca_cert : Certificate authority file location, intended to be used by bpfd and client. cert : Certificate file location, intended to be used by bpfd. key : Certificate key location, intended to be used by bpfd. client_cert : Client certificate file location, intended to be used by bpfd clients ( bpfctl , bpfd-agent , etc). client_key : Client certificate key file location, intended to be used by bpfd clients ( bpfctl , bpfd-agent , etc). If bpfd is running as a systemd service, then the certificates must be accessible by bpfd (owned by the bpfd User and User Group). Config Section: [interfaces] This section of the configuration file allows the XDP Mode for a given interface to be set. If not set, the default value of skb will be used. Multiple interfaces can be configured. [interfaces] [interfaces.eth0] xdp_mode = \"drv\" [interfaces.eth1] xdp_mode = \"hw\" [interfaces.eth2] xdp_mode = \"skb\" Valid fields: xdp_mode : XDP Mode for a given interface. Valid values: [\"drv\"|\"hw\"|\"skb\"] Config Section: [grpc.endpoints] In this section different endpoints can be configured for bpfd to listen on. We currently support TCP sockets with IPv4 and Ipv6 addresses and Unix domain sockets. When using TCP sockets, the tls configuration will be used to secure communication. Unix domain sockets provide a simpler communication with no encryption. These sockets are owned by the bpfd user and user group when running as a systemd or non-root process. Valid fields: type : Specify if the endpoint will listen on a TCP or Unix domain socket. Valid values: [\"tcp\"|\"unix\"] enabled : Configure whether bpfd should listen on the endpoint. Valid values: [\"true\"|\"false\"] address : Exclusive to TCP sockets. Specify the address the endpoint should listen on. Valid values: Any valid IPv4 or IPv6 address. port : Exclusive to TCP sockets. Specify the port bpfd should listen on. Valid values: An integer between 1024 and 65535. path : Exclusive to Unix sockets. Specify the path where the socket will be created. Valid values: A valid unix path. Loading Programs at System Launch bpfd allows the user to specify certain eBPF programs to always be loaded every time the daemon is started. To do so simply create .toml files in the /etc/bpfd/programs.d directory with the following syntax: NOTE: Users can specify multiple programs in a single .toml file OR multiple .toml files [[programs]] name = \"program0\" path = \"/usr/local/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o\" section_name = \"xdp\" program_type = \"xdp\" network_attach = { interface = \"eth0\" , priority = 50 , proceed_on = [ \"pass\" , \"dispatcher_return\" ] } [[programs]] name = \"program1\" path = \"/usr/local/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o\" section_name = \"xdp\" program_type = \"xdp\" network_attach = { interface = \"eth0\" , priority = 55 , proceed_on = [ \"pass\" , \"dispatcher_return\" ] }","title":"Configuration"},{"location":"developer-guide/configuration/#configuration","text":"","title":"Configuration"},{"location":"developer-guide/configuration/#bpfd-configuration-file","text":"bpfd looks for a configuration file to be present at /etc/bpfd/bpfd.toml . If no file is found, defaults are assumed. There is an example at scripts/bpfd.toml , similar to: [ tls ] # REQUIRED ca_cert = \"/etc/bpfd/certs/ca/ca.pem\" cert = \"/etc/bpfd/certs/bpfd/bpfd.pem\" key = \"/etc/bpfd/certs/bpfd/bpfd.key\" client_cert = \"/etc/bpfd/certs/bpfd-client/bpfd-client.pem\" client_key = \"/etc/bpfd/certs/bpfd-client/bpfd-client.key\" [interfaces] [interface.eth0] xdp_mode = \"hw\" # Valid xdp modes are \"hw\", \"skb\" and \"drv\". Default: \"skb\". [[grpc.endpoints]] type = \"tcp\" enabled = true address = \"::1\" port = 50051 [[grpc.endpoints]] type = \"unix\" enabled = false path = \"/run/bpfd/bpfd.sock\" bpfctl and bpfd-agent (which is only used in Kubernetes type deployments) will also read the bpfd configuration file ( /etc/bpfd/bpfd.toml ) to retrieve the bpfd-client certificate file locations.","title":"bpfd Configuration File"},{"location":"developer-guide/configuration/#config-section-tls","text":"This section of the configuration file allows the mTLS certificate authority file locations to be overwritten. If the given certificates exist, then bpfd will use them. Otherwise, bpfd will create them. Default values are shown above. Valid fields: ca_cert : Certificate authority file location, intended to be used by bpfd and client. cert : Certificate file location, intended to be used by bpfd. key : Certificate key location, intended to be used by bpfd. client_cert : Client certificate file location, intended to be used by bpfd clients ( bpfctl , bpfd-agent , etc). client_key : Client certificate key file location, intended to be used by bpfd clients ( bpfctl , bpfd-agent , etc). If bpfd is running as a systemd service, then the certificates must be accessible by bpfd (owned by the bpfd User and User Group).","title":"Config Section: [tls]"},{"location":"developer-guide/configuration/#config-section-interfaces","text":"This section of the configuration file allows the XDP Mode for a given interface to be set. If not set, the default value of skb will be used. Multiple interfaces can be configured. [interfaces] [interfaces.eth0] xdp_mode = \"drv\" [interfaces.eth1] xdp_mode = \"hw\" [interfaces.eth2] xdp_mode = \"skb\" Valid fields: xdp_mode : XDP Mode for a given interface. Valid values: [\"drv\"|\"hw\"|\"skb\"]","title":"Config Section: [interfaces]"},{"location":"developer-guide/configuration/#config-section-grpcendpoints","text":"In this section different endpoints can be configured for bpfd to listen on. We currently support TCP sockets with IPv4 and Ipv6 addresses and Unix domain sockets. When using TCP sockets, the tls configuration will be used to secure communication. Unix domain sockets provide a simpler communication with no encryption. These sockets are owned by the bpfd user and user group when running as a systemd or non-root process. Valid fields: type : Specify if the endpoint will listen on a TCP or Unix domain socket. Valid values: [\"tcp\"|\"unix\"] enabled : Configure whether bpfd should listen on the endpoint. Valid values: [\"true\"|\"false\"] address : Exclusive to TCP sockets. Specify the address the endpoint should listen on. Valid values: Any valid IPv4 or IPv6 address. port : Exclusive to TCP sockets. Specify the port bpfd should listen on. Valid values: An integer between 1024 and 65535. path : Exclusive to Unix sockets. Specify the path where the socket will be created. Valid values: A valid unix path.","title":"Config Section: [grpc.endpoints]"},{"location":"developer-guide/configuration/#loading-programs-at-system-launch","text":"bpfd allows the user to specify certain eBPF programs to always be loaded every time the daemon is started. To do so simply create .toml files in the /etc/bpfd/programs.d directory with the following syntax: NOTE: Users can specify multiple programs in a single .toml file OR multiple .toml files [[programs]] name = \"program0\" path = \"/usr/local/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o\" section_name = \"xdp\" program_type = \"xdp\" network_attach = { interface = \"eth0\" , priority = 50 , proceed_on = [ \"pass\" , \"dispatcher_return\" ] } [[programs]] name = \"program1\" path = \"/usr/local/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o\" section_name = \"xdp\" program_type = \"xdp\" network_attach = { interface = \"eth0\" , priority = 55 , proceed_on = [ \"pass\" , \"dispatcher_return\" ] }","title":"Loading Programs at System Launch"},{"location":"developer-guide/develop-operator/","text":"Developing the bpfd-operator This section is intended to give developer level details regarding the layout and design of the bpfd-operator. At its core the operator was implemented using the operator-sdk framework which make those docs another good resource if anything is missed here. High level design overview This repository houses two main processes, the bpfd-agent and the bpfd-operator along with CRD api definitions for BpfProgram and *Program Objects. The following diagram depicts how all these components work together to create a functioning operator. Building and deploying For building and deploying the bpfd-operator simply see the attached Make help output. make help Usage: make <target> General help Display this help. Local Dependencies kustomize Download kustomize locally if necessary. cm-verifier Download cm-verifier locally if necessary. controller-gen Download controller-gen locally if necessary. envtest Download envtest-setup locally if necessary. opm Download opm locally if necessary. Development manifests Generate WebhookConfiguration, ClusterRole and CustomResourceDefinition objects. generate Generate ALL auto-generated code. generate-register Generate register code see all ` zz_generated.register.go ` files. generate-deepcopy Generate code containing DeepCopy, DeepCopyInto, and DeepCopyObject method implementations see all ` zz_generated.register.go ` files. generate-typed-clients Generate typed client code generate-typed-listers Generate typed listers code generate-typed-informers Generate typed informers code fmt Run go fmt against code. verify Verify all the autogenerated code lint Run golang-ci linter test Run Unit tests. test-integration Run Integration tests. bundle Generate bundle manifests and metadata, then validate generated files. Build build Build bpfd-operator and bpfd-agent binaries. build-images Build bpfd, bpfd-agent, and bpfd-operator images. push-images Push bpfd, bpfd-agent, bpfd-operator images. load-images-kind Load bpfd, bpfd-agent, and bpfd-operator images into the running local kind devel cluster. bundle-build Build the bundle image. bundle-push Push the bundle image. catalog-build Build a catalog image. catalog-push Push a catalog image. CRD Deployment install Install CRDs into the K8s cluster specified in ~/.kube/config. uninstall Uninstall CRDs from the K8s cluster specified in ~/.kube/config. Call with ignore-not-found = true to ignore resource not found errors during deletion. Deployment Dependencies deploy-certmanager Deploy certmanager to the cluster specified in ~/.kube/config. undeploy-certmanager Undeploy certmanager from the cluster specified in ~/.kube/config. Call with ignore-not-found = true to ignore resource not found errors during deletion. Vanilla K8s Deployment setup-kind Setup Kind cluster with certmanager ready for bpfd deployment deploy Deploy bpfd-operator to the K8s cluster specified in ~/.kube/config. undeploy Undeploy bpfd-operator from the K8s cluster specified in ~/.kube/config. Call with ignore-not-found = true to ignore resource not found errors during deletion. kind-reload-images Reload locally build images into a kind cluster and restart the ds and deployment so they ' re picked up. run-on-kind Kind Deploy runs the bpfd-operator on a local kind cluster using local builds of bpfd, bpfd-agent, and bpfd-operator Openshift Deployment deploy-openshift Deploy bpfd-operator to the Openshift cluster specified in ~/.kube/config. undeploy-openshift Undeploy bpfd-operator from the Openshift cluster specified in ~/.kube/config. Call with ignore-not-found = true to ignore resource not found errors during deletion. Running Locally in KIND To run locally in a kind cluster with an up to date build simply run: make run-on-kind The container images used for bpfd , bpfd-agent , and bpfd-operator can also be manually configured, by default local image builds will be used for the kind deployment. BPFD_IMG = <your/image/url> BPFD_AGENT_IMG = <your/image/url> BPFD_OPERATOR_IMG = <your/image/url> make run-on-kind Then rebuild and load a fresh build run: make kind-reload-images Which will rebuild the bpfd-operator, bpfd-agent, and bpfd images and load them into the kind cluster. Testing Locally To run all of the Unit Tests defined in the bpfd-operator controller code simply run make test . To run Integration Tests locally: Build the images locally with the int-test tag. BPFD_AGENT_IMG = quay.io/bpfd/bpfd-agent:int-test BPFD_IMG = quay.io/bpfd/bpfd:int-test BPFD_OPERATOR_IMG = quay.io/bpfd/bpfd-operator:int-test make build-images Run the integration test suite. BPFD_AGENT_IMG = quay.io/bpfd/bpfd-agent:int-test BPFD_IMG = quay.io/bpfd/bpfd:int-test BPFD_OPERATOR_IMG = quay.io/bpfd/bpfd-operator:int-test make test-integration Additionally the integration test can be configured with the following environment variables: KEEP_TEST_CLUSTER : If set to true the test cluster will not be torn down after the integration test suite completes. USE_EXISTING_KIND_CLUSTER : If this is set to the name of the existing kind cluster the integration test suite will use that cluster instead of creating a new one. Project Layout The bpfd-operator project layout is guided by the recommendations from both the operator-sdk framework and the standard golang project-layout . The following is a brief description of the main directories and their contents. NOTE: Bolded directories contain auto-generated code /apis : Contains the K8s CRD api definitions( *_types.go ) for each version along with the auto-generated register and deepcopy methods( zz_generated.deepcopy.go and zz_generate_register.go ). /bundle : Contains the OLM bundle manifests and metadata for the operator. More details can be found in the operator-sdk documentation. /cmd : Contains the main entry-points for the bpfd-operator and bpfd-agent processes. /config : Contains the configuration files for launching the bpfd-operator on a cluster. /bpfd-deployment : Contains static deployment yamls for the bpfd-daemon, this includes two containers, one for bpfd and the other for the bpfd-agent . This DaemonSet yaml is NOT deployed statically by kustomize, instead it's statically copied into the operator image which is then responsible for deploying and configuring the bpfd-daemon DaemonSet. Lastly, this directory also contains the default config used to configure the bpfd-daemon, along with the cert-manager certificates used to encrypt communication between the bpfd-agent and bpfd. /bpfd-operator-deployment: Contains the static deployment yaml for the bpfd-operator. This is deployed statically by kustomize. /cert-manager : Contains the cert-manager manifests used to deploy cert-manager to a cluster. Specifically it just contains a symlink to it's manifests locking us into a specific version. /crd : Contains the CRD manifests for all of the bpfd-operator APIs. /bases : Is where the actual CRD definitions are stored. These definitions are auto-generated by controller-gen . /default : Contains the default deployment configuration for the bpfd-operator. /manifests : Contains the bases for generating OLM manifests. /openshift : Contains the Openshift specific deployment configuration for the bpfd-operator. /prometheus : Contains the prometheus manifests used to deploy Prometheus to a cluster. At the time of writing this the bpfd-operator is NOT exposing any metrics to prometheus, but this is a future goal. /rbac : Contains rbac yamls for getting bpfd and the bpfd-operator up and running on Kubernetes. /bpfd-agent : Contains the rbac yamls for the bpfd-agent. They are automatically generated by kubebuilder via build tags in the bpfd-agent controller code. /bpfd-operator : Contains the rbac yamls for the bpfd-operator. They are automatically generated by kubebuilder via build tags in the bpfd-operator controller code. /samples : Contains sample CR definitions that can be deployed by users for each of our supported APIs. /scorecard : Contains the scorecard manifests used to deploy scorecard to a cluster. At the time of writing this the bpfd-operator is NOT running any scorecard tests. /test : Contains the test manifests used to deploy the bpfd-operator to a kind cluster for integration testing. /controllers : Contains the controller implementations for all of the bpfd-operator APIs. Each controller is responsible for reconciling the state of the cluster with the desired state defined by the user. This is where the source of truth for the auto-generated RBAC can be found, keep an eye out for //+kubebuilder:rbac:groups=bpfd.io comment tags. /bpfdagent : Contains the controller implementations which reconcile user created *Program types to multiple BpfProgram objects. /bpfdoperator : Contains the controller implementations which reconcile global BpfProgram object state back to the user by ensuring the user created *Program objects are reporting the correct status. /hack : Contains any scripts+static files used by the bpfd-operator to facilitate development. /internal : Contains all private library code and is used by the bpfd-operator and bpfd-agent controllers. /pkg : Contains all public library code this is consumed externally and internally. /client : Contains the autogenerated clientset, informers and listers for all of the bpfd-operator APIs. These are autogenerated by the k8s.io/code-generator project , and can be consumed by users wishing to programmatically interact with bpfd specific APIs. /helpers : Contains helper functions which can be consumed by users wishing to programmatically interact with bpfd specific APIs. /test/integration : Contains integration tests for the bpfd-operator. These tests are run against a kind cluster and are responsible for testing the bpfd-operator in a real cluster environment. It uses the kubernetes-testing-framework project to programmatically spin-up all of the required infrastructure for our unit tests. Makefile : Contains all of the make targets used to build, test, and generate code used by the bpfd-operator.","title":"Developing the bpfd-operator"},{"location":"developer-guide/develop-operator/#developing-the-bpfd-operator","text":"This section is intended to give developer level details regarding the layout and design of the bpfd-operator. At its core the operator was implemented using the operator-sdk framework which make those docs another good resource if anything is missed here.","title":"Developing the bpfd-operator"},{"location":"developer-guide/develop-operator/#high-level-design-overview","text":"This repository houses two main processes, the bpfd-agent and the bpfd-operator along with CRD api definitions for BpfProgram and *Program Objects. The following diagram depicts how all these components work together to create a functioning operator.","title":"High level design overview"},{"location":"developer-guide/develop-operator/#building-and-deploying","text":"For building and deploying the bpfd-operator simply see the attached Make help output. make help Usage: make <target> General help Display this help. Local Dependencies kustomize Download kustomize locally if necessary. cm-verifier Download cm-verifier locally if necessary. controller-gen Download controller-gen locally if necessary. envtest Download envtest-setup locally if necessary. opm Download opm locally if necessary. Development manifests Generate WebhookConfiguration, ClusterRole and CustomResourceDefinition objects. generate Generate ALL auto-generated code. generate-register Generate register code see all ` zz_generated.register.go ` files. generate-deepcopy Generate code containing DeepCopy, DeepCopyInto, and DeepCopyObject method implementations see all ` zz_generated.register.go ` files. generate-typed-clients Generate typed client code generate-typed-listers Generate typed listers code generate-typed-informers Generate typed informers code fmt Run go fmt against code. verify Verify all the autogenerated code lint Run golang-ci linter test Run Unit tests. test-integration Run Integration tests. bundle Generate bundle manifests and metadata, then validate generated files. Build build Build bpfd-operator and bpfd-agent binaries. build-images Build bpfd, bpfd-agent, and bpfd-operator images. push-images Push bpfd, bpfd-agent, bpfd-operator images. load-images-kind Load bpfd, bpfd-agent, and bpfd-operator images into the running local kind devel cluster. bundle-build Build the bundle image. bundle-push Push the bundle image. catalog-build Build a catalog image. catalog-push Push a catalog image. CRD Deployment install Install CRDs into the K8s cluster specified in ~/.kube/config. uninstall Uninstall CRDs from the K8s cluster specified in ~/.kube/config. Call with ignore-not-found = true to ignore resource not found errors during deletion. Deployment Dependencies deploy-certmanager Deploy certmanager to the cluster specified in ~/.kube/config. undeploy-certmanager Undeploy certmanager from the cluster specified in ~/.kube/config. Call with ignore-not-found = true to ignore resource not found errors during deletion. Vanilla K8s Deployment setup-kind Setup Kind cluster with certmanager ready for bpfd deployment deploy Deploy bpfd-operator to the K8s cluster specified in ~/.kube/config. undeploy Undeploy bpfd-operator from the K8s cluster specified in ~/.kube/config. Call with ignore-not-found = true to ignore resource not found errors during deletion. kind-reload-images Reload locally build images into a kind cluster and restart the ds and deployment so they ' re picked up. run-on-kind Kind Deploy runs the bpfd-operator on a local kind cluster using local builds of bpfd, bpfd-agent, and bpfd-operator Openshift Deployment deploy-openshift Deploy bpfd-operator to the Openshift cluster specified in ~/.kube/config. undeploy-openshift Undeploy bpfd-operator from the Openshift cluster specified in ~/.kube/config. Call with ignore-not-found = true to ignore resource not found errors during deletion.","title":"Building and deploying"},{"location":"developer-guide/develop-operator/#running-locally-in-kind","text":"To run locally in a kind cluster with an up to date build simply run: make run-on-kind The container images used for bpfd , bpfd-agent , and bpfd-operator can also be manually configured, by default local image builds will be used for the kind deployment. BPFD_IMG = <your/image/url> BPFD_AGENT_IMG = <your/image/url> BPFD_OPERATOR_IMG = <your/image/url> make run-on-kind Then rebuild and load a fresh build run: make kind-reload-images Which will rebuild the bpfd-operator, bpfd-agent, and bpfd images and load them into the kind cluster.","title":"Running Locally in KIND"},{"location":"developer-guide/develop-operator/#testing-locally","text":"To run all of the Unit Tests defined in the bpfd-operator controller code simply run make test . To run Integration Tests locally: Build the images locally with the int-test tag. BPFD_AGENT_IMG = quay.io/bpfd/bpfd-agent:int-test BPFD_IMG = quay.io/bpfd/bpfd:int-test BPFD_OPERATOR_IMG = quay.io/bpfd/bpfd-operator:int-test make build-images Run the integration test suite. BPFD_AGENT_IMG = quay.io/bpfd/bpfd-agent:int-test BPFD_IMG = quay.io/bpfd/bpfd:int-test BPFD_OPERATOR_IMG = quay.io/bpfd/bpfd-operator:int-test make test-integration Additionally the integration test can be configured with the following environment variables: KEEP_TEST_CLUSTER : If set to true the test cluster will not be torn down after the integration test suite completes. USE_EXISTING_KIND_CLUSTER : If this is set to the name of the existing kind cluster the integration test suite will use that cluster instead of creating a new one.","title":"Testing Locally"},{"location":"developer-guide/develop-operator/#project-layout","text":"The bpfd-operator project layout is guided by the recommendations from both the operator-sdk framework and the standard golang project-layout . The following is a brief description of the main directories and their contents. NOTE: Bolded directories contain auto-generated code /apis : Contains the K8s CRD api definitions( *_types.go ) for each version along with the auto-generated register and deepcopy methods( zz_generated.deepcopy.go and zz_generate_register.go ). /bundle : Contains the OLM bundle manifests and metadata for the operator. More details can be found in the operator-sdk documentation. /cmd : Contains the main entry-points for the bpfd-operator and bpfd-agent processes. /config : Contains the configuration files for launching the bpfd-operator on a cluster. /bpfd-deployment : Contains static deployment yamls for the bpfd-daemon, this includes two containers, one for bpfd and the other for the bpfd-agent . This DaemonSet yaml is NOT deployed statically by kustomize, instead it's statically copied into the operator image which is then responsible for deploying and configuring the bpfd-daemon DaemonSet. Lastly, this directory also contains the default config used to configure the bpfd-daemon, along with the cert-manager certificates used to encrypt communication between the bpfd-agent and bpfd. /bpfd-operator-deployment: Contains the static deployment yaml for the bpfd-operator. This is deployed statically by kustomize. /cert-manager : Contains the cert-manager manifests used to deploy cert-manager to a cluster. Specifically it just contains a symlink to it's manifests locking us into a specific version. /crd : Contains the CRD manifests for all of the bpfd-operator APIs. /bases : Is where the actual CRD definitions are stored. These definitions are auto-generated by controller-gen . /default : Contains the default deployment configuration for the bpfd-operator. /manifests : Contains the bases for generating OLM manifests. /openshift : Contains the Openshift specific deployment configuration for the bpfd-operator. /prometheus : Contains the prometheus manifests used to deploy Prometheus to a cluster. At the time of writing this the bpfd-operator is NOT exposing any metrics to prometheus, but this is a future goal. /rbac : Contains rbac yamls for getting bpfd and the bpfd-operator up and running on Kubernetes. /bpfd-agent : Contains the rbac yamls for the bpfd-agent. They are automatically generated by kubebuilder via build tags in the bpfd-agent controller code. /bpfd-operator : Contains the rbac yamls for the bpfd-operator. They are automatically generated by kubebuilder via build tags in the bpfd-operator controller code. /samples : Contains sample CR definitions that can be deployed by users for each of our supported APIs. /scorecard : Contains the scorecard manifests used to deploy scorecard to a cluster. At the time of writing this the bpfd-operator is NOT running any scorecard tests. /test : Contains the test manifests used to deploy the bpfd-operator to a kind cluster for integration testing. /controllers : Contains the controller implementations for all of the bpfd-operator APIs. Each controller is responsible for reconciling the state of the cluster with the desired state defined by the user. This is where the source of truth for the auto-generated RBAC can be found, keep an eye out for //+kubebuilder:rbac:groups=bpfd.io comment tags. /bpfdagent : Contains the controller implementations which reconcile user created *Program types to multiple BpfProgram objects. /bpfdoperator : Contains the controller implementations which reconcile global BpfProgram object state back to the user by ensuring the user created *Program objects are reporting the correct status. /hack : Contains any scripts+static files used by the bpfd-operator to facilitate development. /internal : Contains all private library code and is used by the bpfd-operator and bpfd-agent controllers. /pkg : Contains all public library code this is consumed externally and internally. /client : Contains the autogenerated clientset, informers and listers for all of the bpfd-operator APIs. These are autogenerated by the k8s.io/code-generator project , and can be consumed by users wishing to programmatically interact with bpfd specific APIs. /helpers : Contains helper functions which can be consumed by users wishing to programmatically interact with bpfd specific APIs. /test/integration : Contains integration tests for the bpfd-operator. These tests are run against a kind cluster and are responsible for testing the bpfd-operator in a real cluster environment. It uses the kubernetes-testing-framework project to programmatically spin-up all of the required infrastructure for our unit tests. Makefile : Contains all of the make targets used to build, test, and generate code used by the bpfd-operator.","title":"Project Layout"},{"location":"developer-guide/documentation/","text":"Documentation This section describes how to modify the related documentation around bpfd. All bpfd's documentation is written in Markdown, and leverages mkdocs to generate a static site, which is hosted on netlify . If this is the first time building using mkdocs , jump to the Development Environment Setup section for help installing the tooling. Documentation Notes This section describes some notes on the dos and don'ts when writing documentation. Website Management The headings and layout of the website, as well as other configuration settings, are managed from the mkdocs.yml file in the project root directory. Markdown Style When writing documentation via a Markdown file, the following format has been followed: Text on a given line should not exceed 100 characters, unless it's example syntax or a link that should be broken up. Each new sentence should start on a new line. That way, if text needs to be inserted, whole paragraphs don't need to be adjusted. Links to other markdown files are relative to the file the link is placed in. Governance Files There are a set of well known governance files that are typically placed in the root directory of most projects, like README.md, MAINTAINERS.md, CONTRIBUTING.md, etc. mkdocs expects all files used in the static website to be located under a common directory, docs/ for bpfd. To reference the governance files from the static website, a directory ( docs/governance/ ) was created with a file for each governance file, the only contains --8<-- and the file name. This indicates to mkdocs to pull the additional file from the project root directory. For example: docs/governance/MEETINGS.md NOTE: This works for the website generation, but if a Markdown file is viewed through Github (not the website), the link is broken. So these files should only be linked from docs/index.md and mkdocs.yml . docs/developer-guide/api-spec.md The file docs/developer-guide/api-spec.md documents the CRDs used in a Kubernetes deployment. The contents are auto-generated when PRs are pushed to Github. The script scripts/make-docs.sh manages the generation of this file. Generate Documentation On each PR pushed to https://github.com/bpfd-dev/bpfd the documentation is generated. To preview of the generated site, click on the Details link of the netlify/bpfd/deploy-preview Check from the Github GUI. If you would like to test locally, build and preview the generated documentation, from the bpfd root directory, use mkdocs to build: cd bpfd/ mkdocs build To preview from a build on a local machine, start the mkdocs dev-server with the command below, then open up http://127.0.0.1:8000/ in your browser, and you'll see the default home page being displayed: mkdocs serve To preview from a build on a remote machine, start the mkdocs dev-server with the command below, then open up http://<ServerIP>:8000/ in your browser, and you'll see the default home page being displayed: mkdocs serve -a 0.0.0.0:8000 Development Environment Setup The recommended installation method is using pip . pip install mkdocs pip install pymdown-extensions pip install mkdocs-material Once installed, ensure the mkdocs is in your PATH: mkdocs -V mkdocs, version 1.4.3 from /home/$USER/.local/lib/python3.11/site-packages/mkdocs (Python 3.11)","title":"Documentation"},{"location":"developer-guide/documentation/#documentation","text":"This section describes how to modify the related documentation around bpfd. All bpfd's documentation is written in Markdown, and leverages mkdocs to generate a static site, which is hosted on netlify . If this is the first time building using mkdocs , jump to the Development Environment Setup section for help installing the tooling.","title":"Documentation"},{"location":"developer-guide/documentation/#documentation-notes","text":"This section describes some notes on the dos and don'ts when writing documentation.","title":"Documentation Notes"},{"location":"developer-guide/documentation/#website-management","text":"The headings and layout of the website, as well as other configuration settings, are managed from the mkdocs.yml file in the project root directory.","title":"Website Management"},{"location":"developer-guide/documentation/#markdown-style","text":"When writing documentation via a Markdown file, the following format has been followed: Text on a given line should not exceed 100 characters, unless it's example syntax or a link that should be broken up. Each new sentence should start on a new line. That way, if text needs to be inserted, whole paragraphs don't need to be adjusted. Links to other markdown files are relative to the file the link is placed in.","title":"Markdown Style"},{"location":"developer-guide/documentation/#governance-files","text":"There are a set of well known governance files that are typically placed in the root directory of most projects, like README.md, MAINTAINERS.md, CONTRIBUTING.md, etc. mkdocs expects all files used in the static website to be located under a common directory, docs/ for bpfd. To reference the governance files from the static website, a directory ( docs/governance/ ) was created with a file for each governance file, the only contains --8<-- and the file name. This indicates to mkdocs to pull the additional file from the project root directory. For example: docs/governance/MEETINGS.md NOTE: This works for the website generation, but if a Markdown file is viewed through Github (not the website), the link is broken. So these files should only be linked from docs/index.md and mkdocs.yml .","title":"Governance Files"},{"location":"developer-guide/documentation/#docsdeveloper-guideapi-specmd","text":"The file docs/developer-guide/api-spec.md documents the CRDs used in a Kubernetes deployment. The contents are auto-generated when PRs are pushed to Github. The script scripts/make-docs.sh manages the generation of this file.","title":"docs/developer-guide/api-spec.md"},{"location":"developer-guide/documentation/#generate-documentation","text":"On each PR pushed to https://github.com/bpfd-dev/bpfd the documentation is generated. To preview of the generated site, click on the Details link of the netlify/bpfd/deploy-preview Check from the Github GUI. If you would like to test locally, build and preview the generated documentation, from the bpfd root directory, use mkdocs to build: cd bpfd/ mkdocs build To preview from a build on a local machine, start the mkdocs dev-server with the command below, then open up http://127.0.0.1:8000/ in your browser, and you'll see the default home page being displayed: mkdocs serve To preview from a build on a remote machine, start the mkdocs dev-server with the command below, then open up http://<ServerIP>:8000/ in your browser, and you'll see the default home page being displayed: mkdocs serve -a 0.0.0.0:8000","title":"Generate Documentation"},{"location":"developer-guide/documentation/#development-environment-setup","text":"The recommended installation method is using pip . pip install mkdocs pip install pymdown-extensions pip install mkdocs-material Once installed, ensure the mkdocs is in your PATH: mkdocs -V mkdocs, version 1.4.3 from /home/$USER/.local/lib/python3.11/site-packages/mkdocs (Python 3.11)","title":"Development Environment Setup"},{"location":"developer-guide/image-build/","text":"bpfd Container Images Container images for the bpfd and bpfctl binaries are automatically built and pushed to quay.io/bpfd whenever code is merged into the main branch of the github.com/bpfd-dev/bpfd repository under the :main tag. Building the images locally bpfd docker build -f /packaging/container-deployment/Containerfile.bpfd . -t bpfd:local bpfctl docker build -f /packaging/container-deployment/Containerfile.bpfctl . -t bpfctl:local Running locally in container bpfd sudo docker run --init --privileged --net = host -v /etc/bpfd/certs/:/etc/bpfd/certs/ -v /sys/fs/bpf:/sys/fs/bpf quay.io/bpfd/bpfd:main bpfctl sudo docker run --init --privileged --net = host -v /etc/bpfd/certs/:/etc/bpfd/certs/ quay.io/bpfd/bpfctl:main <COMMANDS>","title":"bpfd Container Images"},{"location":"developer-guide/image-build/#bpfd-container-images","text":"Container images for the bpfd and bpfctl binaries are automatically built and pushed to quay.io/bpfd whenever code is merged into the main branch of the github.com/bpfd-dev/bpfd repository under the :main tag.","title":"bpfd Container Images"},{"location":"developer-guide/image-build/#building-the-images-locally","text":"","title":"Building the images locally"},{"location":"developer-guide/image-build/#bpfd","text":"docker build -f /packaging/container-deployment/Containerfile.bpfd . -t bpfd:local","title":"bpfd"},{"location":"developer-guide/image-build/#bpfctl","text":"docker build -f /packaging/container-deployment/Containerfile.bpfctl . -t bpfctl:local","title":"bpfctl"},{"location":"developer-guide/image-build/#running-locally-in-container","text":"","title":"Running locally in container"},{"location":"developer-guide/image-build/#bpfd_1","text":"sudo docker run --init --privileged --net = host -v /etc/bpfd/certs/:/etc/bpfd/certs/ -v /sys/fs/bpf:/sys/fs/bpf quay.io/bpfd/bpfd:main","title":"bpfd"},{"location":"developer-guide/image-build/#bpfctl_1","text":"sudo docker run --init --privileged --net = host -v /etc/bpfd/certs/:/etc/bpfd/certs/ quay.io/bpfd/bpfctl:main <COMMANDS>","title":"bpfctl"},{"location":"developer-guide/linux-capabilities/","text":"Linux Capabilities Linux divides the privileges traditionally associated with superuser into distinct units, known as capabilities, which can be independently enabled and disabled. Capabilities are a per-thread attribute. See capabilities man-page . When bpfd is run as a systemd service, the set of linux capabilities are restricted to only the required set of capabilities via the bpfd.service file using the AmbientCapabilities and CapabilityBoundingSet fields (see bpfd.service ). All spawned threads are stripped of all capabilities, removing all sudo privileges (see drop_linux_capabilities() usage), leaving only the main thread with only the needed set of capabilities. Debugging Linux Capabilities As new features are added, the set of Linux capabilities required by bpfd may change over time. The following describes the steps to determine the set of capabilities required by bpfd. If there are any Permission denied (os error 13) type errors when starting or running bpfd as a systemd service, adjusting the linux capabilities is a good place to start. Determine Required Capabilities The first step is to turn all capabilities on and see if that fixes the problem. This can be done without recompiling the code by editing bpfd.service . Comment out the finite list of granted capabilities and set to ~ , which indicates all capabilities. sudo vi /usr/lib/systemd/system/bpfd.service : [ Service ] : AmbientCapabilities = ~ CapabilityBoundingSet = ~ #AmbientCapabilities=CAP_BPF CAP_DAC_OVERRIDE CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SETPCAP CAP_SYS_ADMIN CAP_SYS_RESOURCE #CapabilityBoundingSet=CAP_BPF CAP_DAC_OVERRIDE CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SETPCAP CAP_SYS_ADMIN CAP_SYS_RESOURCE Reload the service file and start/restart bpfd and watch the bpfd logs and see if the problem is resolved: sudo systemctl daemon-reload sudo systemctl start bpfd If so, then the next step is to watch the set of capabilities being requested by bpfd. Run the bcc capable tool to watch capabilities being requested real-time and restart bpfd: $ sudo /usr/share/bcc/tools/capable TIME UID PID COMM CAP NAME AUDIT : 16 :36:00 979 75553 tokio-runtime-w 8 CAP_SETPCAP 1 16 :36:00 979 75553 tokio-runtime-w 8 CAP_SETPCAP 1 16 :36:00 979 75553 tokio-runtime-w 8 CAP_SETPCAP 1 16 :36:00 0 616 systemd-journal 19 CAP_SYS_PTRACE 1 16 :36:00 0 616 systemd-journal 19 CAP_SYS_PTRACE 1 16 :36:00 979 75550 bpfd 24 CAP_SYS_RESOURCE 1 16 :36:00 979 75550 bpfd 1 CAP_DAC_OVERRIDE 1 16 :36:00 979 75550 bpfd 21 CAP_SYS_ADMIN 1 16 :36:00 979 75550 bpfd 21 CAP_SYS_ADMIN 1 16 :36:00 0 75555 modprobe 16 CAP_SYS_MODULE 1 16 :36:00 0 628 systemd-udevd 2 CAP_DAC_READ_SEARCH 1 16 :36:00 0 75556 bpf_preload 24 CAP_SYS_RESOURCE 1 16 :36:00 0 75556 bpf_preload 39 CAP_BPF 1 16 :36:00 0 75556 bpf_preload 39 CAP_BPF 1 16 :36:00 0 75556 bpf_preload 39 CAP_BPF 1 16 :36:00 0 75556 bpf_preload 38 CAP_PERFMON 1 16 :36:00 0 75556 bpf_preload 38 CAP_PERFMON 1 16 :36:00 0 75556 bpf_preload 38 CAP_PERFMON 1 : Compare the output to list in bpfd.service and determine the delta. Determine Capabilities Per Thread For additional debugging, it may be helpful to know the granted capabilities on a per thread basis. As mentioned above, all spawned threads are stripped of all Linux capabilities, so if a thread is requesting a capability, that functionality should be moved off the spawned thread and onto the main thread. First, determine the bpfd process id, then determine the set of threads: $ ps -ef | grep bpfd : bpfd 75550 1 0 16 :36 ? 00 :00:00 /usr/sbin/bpfd : $ ps -T -p 75550 PID SPID TTY TIME CMD 75550 75550 ? 00 :00:00 bpfd 75550 75551 ? 00 :00:00 tokio-runtime-w 75550 75552 ? 00 :00:00 tokio-runtime-w 75550 75553 ? 00 :00:00 tokio-runtime-w 75550 75554 ? 00 :00:00 tokio-runtime-w Then dump the capabilities of each thread: $ grep Cap /proc/75550/status CapInh: 000000c001201106 CapPrm: 000000c001201106 CapEff: 000000c001201106 CapBnd: 000000c001201106 CapAmb: 000000c001201106 $ grep Cap /proc/75551/status CapInh: 0000000000000000 CapPrm: 0000000000000000 CapEff: 0000000000000000 CapBnd: 0000000000000000 CapAmb: 0000000000000000 $ grep Cap /proc/75552/status CapInh: 0000000000000000 CapPrm: 0000000000000000 CapEff: 0000000000000000 CapBnd: 0000000000000000 CapAmb: 0000000000000000 : $ capsh --decode=000000c001201106 0x000000c001201106=cap_dac_override,cap_dac_read_search,cap_setpcap,cap_net_admin,cap_sys_admin,cap_sys_resource,cap_perfmon,cap_bpf Removing CAP_BPF from bpfd Clients One of the advantages of using bpfd is that it is doing all the loading and unloading of eBPF programs, so it requires CAP_BPF, but clients of bpfd are just making gRPC calls to bpfd, so they do not need to be privileged or require CAP_BPF. It must be noted that this is only true for kernels 5.19 or higher. Prior to kernel 5.19 , all eBPF sys calls required CAP_BPF, which are used to access maps shared between the BFP program and the userspace program. In kernel 5.19, a change went in that only requires CAP_BPF for map creation (BPF_MAP_CREATE) and loading programs (BPF_PROG_LOAD). See bpf: refine kernel.unprivileged_bpf_disabled behaviour .","title":"Linux Capabilities"},{"location":"developer-guide/linux-capabilities/#linux-capabilities","text":"Linux divides the privileges traditionally associated with superuser into distinct units, known as capabilities, which can be independently enabled and disabled. Capabilities are a per-thread attribute. See capabilities man-page . When bpfd is run as a systemd service, the set of linux capabilities are restricted to only the required set of capabilities via the bpfd.service file using the AmbientCapabilities and CapabilityBoundingSet fields (see bpfd.service ). All spawned threads are stripped of all capabilities, removing all sudo privileges (see drop_linux_capabilities() usage), leaving only the main thread with only the needed set of capabilities.","title":"Linux Capabilities"},{"location":"developer-guide/linux-capabilities/#debugging-linux-capabilities","text":"As new features are added, the set of Linux capabilities required by bpfd may change over time. The following describes the steps to determine the set of capabilities required by bpfd. If there are any Permission denied (os error 13) type errors when starting or running bpfd as a systemd service, adjusting the linux capabilities is a good place to start.","title":"Debugging Linux Capabilities"},{"location":"developer-guide/linux-capabilities/#determine-required-capabilities","text":"The first step is to turn all capabilities on and see if that fixes the problem. This can be done without recompiling the code by editing bpfd.service . Comment out the finite list of granted capabilities and set to ~ , which indicates all capabilities. sudo vi /usr/lib/systemd/system/bpfd.service : [ Service ] : AmbientCapabilities = ~ CapabilityBoundingSet = ~ #AmbientCapabilities=CAP_BPF CAP_DAC_OVERRIDE CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SETPCAP CAP_SYS_ADMIN CAP_SYS_RESOURCE #CapabilityBoundingSet=CAP_BPF CAP_DAC_OVERRIDE CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SETPCAP CAP_SYS_ADMIN CAP_SYS_RESOURCE Reload the service file and start/restart bpfd and watch the bpfd logs and see if the problem is resolved: sudo systemctl daemon-reload sudo systemctl start bpfd If so, then the next step is to watch the set of capabilities being requested by bpfd. Run the bcc capable tool to watch capabilities being requested real-time and restart bpfd: $ sudo /usr/share/bcc/tools/capable TIME UID PID COMM CAP NAME AUDIT : 16 :36:00 979 75553 tokio-runtime-w 8 CAP_SETPCAP 1 16 :36:00 979 75553 tokio-runtime-w 8 CAP_SETPCAP 1 16 :36:00 979 75553 tokio-runtime-w 8 CAP_SETPCAP 1 16 :36:00 0 616 systemd-journal 19 CAP_SYS_PTRACE 1 16 :36:00 0 616 systemd-journal 19 CAP_SYS_PTRACE 1 16 :36:00 979 75550 bpfd 24 CAP_SYS_RESOURCE 1 16 :36:00 979 75550 bpfd 1 CAP_DAC_OVERRIDE 1 16 :36:00 979 75550 bpfd 21 CAP_SYS_ADMIN 1 16 :36:00 979 75550 bpfd 21 CAP_SYS_ADMIN 1 16 :36:00 0 75555 modprobe 16 CAP_SYS_MODULE 1 16 :36:00 0 628 systemd-udevd 2 CAP_DAC_READ_SEARCH 1 16 :36:00 0 75556 bpf_preload 24 CAP_SYS_RESOURCE 1 16 :36:00 0 75556 bpf_preload 39 CAP_BPF 1 16 :36:00 0 75556 bpf_preload 39 CAP_BPF 1 16 :36:00 0 75556 bpf_preload 39 CAP_BPF 1 16 :36:00 0 75556 bpf_preload 38 CAP_PERFMON 1 16 :36:00 0 75556 bpf_preload 38 CAP_PERFMON 1 16 :36:00 0 75556 bpf_preload 38 CAP_PERFMON 1 : Compare the output to list in bpfd.service and determine the delta.","title":"Determine Required Capabilities"},{"location":"developer-guide/linux-capabilities/#determine-capabilities-per-thread","text":"For additional debugging, it may be helpful to know the granted capabilities on a per thread basis. As mentioned above, all spawned threads are stripped of all Linux capabilities, so if a thread is requesting a capability, that functionality should be moved off the spawned thread and onto the main thread. First, determine the bpfd process id, then determine the set of threads: $ ps -ef | grep bpfd : bpfd 75550 1 0 16 :36 ? 00 :00:00 /usr/sbin/bpfd : $ ps -T -p 75550 PID SPID TTY TIME CMD 75550 75550 ? 00 :00:00 bpfd 75550 75551 ? 00 :00:00 tokio-runtime-w 75550 75552 ? 00 :00:00 tokio-runtime-w 75550 75553 ? 00 :00:00 tokio-runtime-w 75550 75554 ? 00 :00:00 tokio-runtime-w Then dump the capabilities of each thread: $ grep Cap /proc/75550/status CapInh: 000000c001201106 CapPrm: 000000c001201106 CapEff: 000000c001201106 CapBnd: 000000c001201106 CapAmb: 000000c001201106 $ grep Cap /proc/75551/status CapInh: 0000000000000000 CapPrm: 0000000000000000 CapEff: 0000000000000000 CapBnd: 0000000000000000 CapAmb: 0000000000000000 $ grep Cap /proc/75552/status CapInh: 0000000000000000 CapPrm: 0000000000000000 CapEff: 0000000000000000 CapBnd: 0000000000000000 CapAmb: 0000000000000000 : $ capsh --decode=000000c001201106 0x000000c001201106=cap_dac_override,cap_dac_read_search,cap_setpcap,cap_net_admin,cap_sys_admin,cap_sys_resource,cap_perfmon,cap_bpf","title":"Determine Capabilities Per Thread"},{"location":"developer-guide/linux-capabilities/#removing-cap_bpf-from-bpfd-clients","text":"One of the advantages of using bpfd is that it is doing all the loading and unloading of eBPF programs, so it requires CAP_BPF, but clients of bpfd are just making gRPC calls to bpfd, so they do not need to be privileged or require CAP_BPF. It must be noted that this is only true for kernels 5.19 or higher. Prior to kernel 5.19 , all eBPF sys calls required CAP_BPF, which are used to access maps shared between the BFP program and the userspace program. In kernel 5.19, a change went in that only requires CAP_BPF for map creation (BPF_MAP_CREATE) and loading programs (BPF_PROG_LOAD). See bpf: refine kernel.unprivileged_bpf_disabled behaviour .","title":"Removing CAP_BPF from bpfd Clients"},{"location":"developer-guide/logging/","text":"Logging This section describes how to enable logging in different bpfd deployments. Local Privileged Process bpfd and bpfctl use the env_logger crate to log messages to the terminal. By default, only error messages are logged, but that can be overwritten by setting the RUST_LOG environment variable. Valid values: error warn info debug trace Example: $ sudo RUST_LOG = info /usr/local/bin/bpfd [2022-08-08T20:29:31Z INFO bpfd] Log using env_logger [2022-08-08T20:29:31Z INFO bpfd::server] Loading static programs from /etc/bpfd/programs.d [2022-08-08T20:29:31Z INFO bpfd::server::bpf] Map veth12fa8e3 to 13 [2022-08-08T20:29:31Z INFO bpfd::server] Listening on [::1]:50051 [2022-08-08T20:29:31Z INFO bpfd::server::bpf] Program added: 1 programs attached to veth12fa8e3 [2022-08-08T20:29:31Z INFO bpfd::server] Loaded static program pass with UUID d9fd88df-d039-4e64-9f63-19f3e08915ce bpfctl has a minimal set of logs, but the infrastructure is in place if needed for future debugging. sudo RUST_LOG=info bpfctl list [2023-05-09T12:46:59Z WARN bpfctl] Unable to read config file, using defaults [2023-05-09T12:46:59Z INFO bpfctl] Using UNIX socket as transport UUID Type Name Location Metadata Systemd Service If bpfd is running as a systemd service, then bpfd will log to journald. As with env_logger, by default, info and higher messages are logged, but that can be overwritten by setting the RUST_LOG environment variable. bpfctl won't be run as a service, so it always uses env_logger. Example: sudo vi /usr/lib/systemd/system/bpfd.service [Unit] Description=Run bpfd as a service DefaultDependencies=no After=network.target [Service] Environment=\"RUST_LOG=Info\" <==== Set Log Level Here ExecStart=/usr/sbin/bpfd MemoryAccounting=true MemoryLow=infinity MemoryMax=infinity User=bpfd Group=bpfd AmbientCapabilities=CAP_BPF CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SYS_ADMIN CAP_SYS_RESOURCE CapabilityBoundingSet=CAP_BPF CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SYS_ADMIN CAP_SYS_RESOURCE Start the service: sudo systemctl start bpfd.service Check the logs: $ sudo journalctl -f -u bpfd Aug 08 16:25:04 ebpf03 systemd[1]: Started bpfd.service - Run bpfd as a service. Aug 08 16:25:04 ebpf03 bpfd[180118]: Log using journald Aug 08 16:25:04 ebpf03 bpfd[180118]: Loading static programs from /etc/bpfd/programs.d Aug 08 16:25:04 ebpf03 bpfd[180118]: Map veth12fa8e3 to 13 Aug 08 16:25:04 ebpf03 bpfd[180118]: Listening on [::1]:50051 Aug 08 16:25:04 ebpf03 bpfd[180118]: Program added: 1 programs attached to veth12fa8e3 Aug 08 16:25:04 ebpf03 bpfd[180118]: Loaded static program pass with UUID a3ffa14a-786d-48ad-b0cd-a4802f0f10b6 Stop the service: sudo systemctl stop bpfd.service Kubernetes Deployment When bpfd is run in a Kubernetes deployment, there is the bpfd Daemonset that runs on every node and the bpd Operator that runns on the control plane: kubectl get pods -A NAMESPACE NAME READY STATUS RESTARTS AGE bpfd bpfd-daemon-dgqzw 2/2 Running 0 3d22h bpfd bpfd-daemon-gqsgd 2/2 Running 0 3d22h bpfd bpfd-daemon-zx9xr 2/2 Running 0 3d22h bpfd bpfd-operator-7fbf4888c4-z8w76 2/2 Running 0 3d22h : bpfd Daemonset bpfd and bpfd-agent are running in the bpfd daemonset. To see the logs: kubectl logs -n bpfd bpfd-daemon-dgqzw -c bpfd [2023-05-05T14:41:26Z INFO bpfd] Log using env_logger [2023-05-05T14:41:26Z INFO bpfd] Has CAP_BPF: false [2023-05-05T14:41:26Z INFO bpfd] Has CAP_SYS_ADMIN: true : kubectl logs -n bpfd bpfd-daemon-dgqzw -c bpfd-agent 2023-05-05T14:41:27Z INFO controller-runtime.metrics Metrics server is starting to listen {\"addr\": \":8080\"} 2023-05-05T14:41:27Z INFO tls-internal Reading... {\"Default config path\": \"/etc/bpfd/bpfd.toml\"} 2023-05-05T14:41:27Z INFO setup Waiting for active connection to bpfd at %s {\"addr\": \"localhost:50051\", \"creds\": {}} : To change the log level, edit the bpfd-config ConfigMap. The bpfd-operator will detect the change and restart the bpfd daemonset with the updated values. kubectl edit configmaps -n bpfd bpfd-config apiVersion: v1 data: bpfd.agent.image: quay.io/bpfd/bpfd-agent:main bpfd.image: quay.io/bpfd/bpfd:main bpfd.log.level: debug <==== Set Log Level Here bpfd.toml: | [tls] # REQUIRED ca_cert = \"/etc/bpfd/certs/ca/ca.crt\" cert = \"/etc/bpfd/certs/bpfd/tls.crt\" key = \"/etc/bpfd/certs/bpfd/tls.key\" client_cert = \"/etc/bpfd/certs/bpfd-client/tls.crt\" client_key = \"/etc/bpfd/certs/bpfd-client/tls.key\" kind: ConfigMap metadata: annotations: kubectl.kubernetes.io/last-applied-configuration: | {\"apiVersion\":\"v1\",\"data\":{\"bpfd.agent.image\":\"quay.io/bpfd/bpfd-agent:main\",\"bpfd.image\":\"quay.io/bpfd/bpfd:main\",\"bpfd.log.level\":\"debug\",\"bpfd.na> creationTimestamp: \"2023-05-05T14:41:19Z\" name: bpfd-config namespace: bpfd resourceVersion: \"700803\" uid: 0cc04af4-032c-4712-b824-748b321d319b bpfd Operator The bpfd Operator is running as a Deployment with a ReplicaSet of one. It runs with the containers bpfd-operator and kube-rbac-proxy . To see the logs: kubectl logs -n bpfd bpfd-operator-7fbf4888c4-z8w76 -c bpfd-operator {\"level\":\"info\",\"ts\":\"2023-05-09T18:37:11Z\",\"logger\":\"controller-runtime.metrics\",\"msg\":\"Metrics server is starting to listen\",\"addr\":\"127.0.0.1:8080\"} {\"level\":\"info\",\"ts\":\"2023-05-09T18:37:11Z\",\"logger\":\"setup\",\"msg\":\"starting manager\"} {\"level\":\"info\",\"ts\":\"2023-05-09T18:37:11Z\",\"msg\":\"Starting server\",\"kind\":\"health probe\",\"addr\":\"[::]:8081\"} {\"level\":\"info\",\"ts\":\"2023-05-09T18:37:11Z\",\"msg\":\"Starting server\",\"path\":\"/metrics\",\"kind\":\"metrics\",\"addr\":\"127.0.0.1:8080\"} I0509 18:37:11.262885 1 leaderelection.go:248] attempting to acquire leader lease bpfd/8730d955.bpfd.io... I0509 18:37:11.268918 1 leaderelection.go:258] successfully acquired lease bpfd/8730d955.bpfd.io {\"level\":\"info\",\"ts\":\"2023-05-09T18:37:11Z\",\"msg\":\"Starting EventSource\",\"controller\":\"configmap\",\"controllerGroup\":\"\",\"controllerKind\":\"ConfigMap\",\"source\":\"kind source: *v1.ConfigMap\"} : kubectl logs -n bpfd bpfd-operator-7fbf4888c4-z8w76 -c kube-rbac-proxy I0509 18:37:11.063386 1 main.go:186] Valid token audiences: I0509 18:37:11.063485 1 main.go:316] Generating self signed cert as no cert is provided I0509 18:37:11.955256 1 main.go:366] Starting TCP socket on 0.0.0.0:8443 I0509 18:37:11.955849 1 main.go:373] Listening securely on 0.0.0.0:8443 To change the log level, edit the bpfd-operator Deployment. The change will get detected and the bpfd operator pod will get restarted with the updated log level. kubectl edit deployment -n bpfd bpfd-operator apiVersion: apps/v1 kind: Deployment metadata: annotations: deployment.kubernetes.io/revision: \"1\" kubectl.kubernetes.io/last-applied-configuration: | {\"apiVersion\":\"apps/v1\",\"kind\":\"Deployment\",\"metadata\":{\"annotations\":{},\"labels\":{\"app.kubernetes.io/component\":\"manager\",\"app.kubernetes.io/create> creationTimestamp: \"2023-05-09T18:37:08Z\" generation: 1 : spec: : template: metadata: : spec: containers: - args: : - args: - --health-probe-bind-address=:8081 - --metrics-bind-address=127.0.0.1:8080 - --leader-elect command: - /bpfd-operator env: - name: GO_LOG value: info <==== Set Log Level Here image: quay.io/bpfd/bpfd-operator:main imagePullPolicy: IfNotPresent :","title":"Logging"},{"location":"developer-guide/logging/#logging","text":"This section describes how to enable logging in different bpfd deployments.","title":"Logging"},{"location":"developer-guide/logging/#local-privileged-process","text":"bpfd and bpfctl use the env_logger crate to log messages to the terminal. By default, only error messages are logged, but that can be overwritten by setting the RUST_LOG environment variable. Valid values: error warn info debug trace Example: $ sudo RUST_LOG = info /usr/local/bin/bpfd [2022-08-08T20:29:31Z INFO bpfd] Log using env_logger [2022-08-08T20:29:31Z INFO bpfd::server] Loading static programs from /etc/bpfd/programs.d [2022-08-08T20:29:31Z INFO bpfd::server::bpf] Map veth12fa8e3 to 13 [2022-08-08T20:29:31Z INFO bpfd::server] Listening on [::1]:50051 [2022-08-08T20:29:31Z INFO bpfd::server::bpf] Program added: 1 programs attached to veth12fa8e3 [2022-08-08T20:29:31Z INFO bpfd::server] Loaded static program pass with UUID d9fd88df-d039-4e64-9f63-19f3e08915ce bpfctl has a minimal set of logs, but the infrastructure is in place if needed for future debugging. sudo RUST_LOG=info bpfctl list [2023-05-09T12:46:59Z WARN bpfctl] Unable to read config file, using defaults [2023-05-09T12:46:59Z INFO bpfctl] Using UNIX socket as transport UUID Type Name Location Metadata","title":"Local Privileged Process"},{"location":"developer-guide/logging/#systemd-service","text":"If bpfd is running as a systemd service, then bpfd will log to journald. As with env_logger, by default, info and higher messages are logged, but that can be overwritten by setting the RUST_LOG environment variable. bpfctl won't be run as a service, so it always uses env_logger. Example: sudo vi /usr/lib/systemd/system/bpfd.service [Unit] Description=Run bpfd as a service DefaultDependencies=no After=network.target [Service] Environment=\"RUST_LOG=Info\" <==== Set Log Level Here ExecStart=/usr/sbin/bpfd MemoryAccounting=true MemoryLow=infinity MemoryMax=infinity User=bpfd Group=bpfd AmbientCapabilities=CAP_BPF CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SYS_ADMIN CAP_SYS_RESOURCE CapabilityBoundingSet=CAP_BPF CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SYS_ADMIN CAP_SYS_RESOURCE Start the service: sudo systemctl start bpfd.service Check the logs: $ sudo journalctl -f -u bpfd Aug 08 16:25:04 ebpf03 systemd[1]: Started bpfd.service - Run bpfd as a service. Aug 08 16:25:04 ebpf03 bpfd[180118]: Log using journald Aug 08 16:25:04 ebpf03 bpfd[180118]: Loading static programs from /etc/bpfd/programs.d Aug 08 16:25:04 ebpf03 bpfd[180118]: Map veth12fa8e3 to 13 Aug 08 16:25:04 ebpf03 bpfd[180118]: Listening on [::1]:50051 Aug 08 16:25:04 ebpf03 bpfd[180118]: Program added: 1 programs attached to veth12fa8e3 Aug 08 16:25:04 ebpf03 bpfd[180118]: Loaded static program pass with UUID a3ffa14a-786d-48ad-b0cd-a4802f0f10b6 Stop the service: sudo systemctl stop bpfd.service","title":"Systemd Service"},{"location":"developer-guide/logging/#kubernetes-deployment","text":"When bpfd is run in a Kubernetes deployment, there is the bpfd Daemonset that runs on every node and the bpd Operator that runns on the control plane: kubectl get pods -A NAMESPACE NAME READY STATUS RESTARTS AGE bpfd bpfd-daemon-dgqzw 2/2 Running 0 3d22h bpfd bpfd-daemon-gqsgd 2/2 Running 0 3d22h bpfd bpfd-daemon-zx9xr 2/2 Running 0 3d22h bpfd bpfd-operator-7fbf4888c4-z8w76 2/2 Running 0 3d22h :","title":"Kubernetes Deployment"},{"location":"developer-guide/logging/#bpfd-daemonset","text":"bpfd and bpfd-agent are running in the bpfd daemonset. To see the logs: kubectl logs -n bpfd bpfd-daemon-dgqzw -c bpfd [2023-05-05T14:41:26Z INFO bpfd] Log using env_logger [2023-05-05T14:41:26Z INFO bpfd] Has CAP_BPF: false [2023-05-05T14:41:26Z INFO bpfd] Has CAP_SYS_ADMIN: true : kubectl logs -n bpfd bpfd-daemon-dgqzw -c bpfd-agent 2023-05-05T14:41:27Z INFO controller-runtime.metrics Metrics server is starting to listen {\"addr\": \":8080\"} 2023-05-05T14:41:27Z INFO tls-internal Reading... {\"Default config path\": \"/etc/bpfd/bpfd.toml\"} 2023-05-05T14:41:27Z INFO setup Waiting for active connection to bpfd at %s {\"addr\": \"localhost:50051\", \"creds\": {}} : To change the log level, edit the bpfd-config ConfigMap. The bpfd-operator will detect the change and restart the bpfd daemonset with the updated values. kubectl edit configmaps -n bpfd bpfd-config apiVersion: v1 data: bpfd.agent.image: quay.io/bpfd/bpfd-agent:main bpfd.image: quay.io/bpfd/bpfd:main bpfd.log.level: debug <==== Set Log Level Here bpfd.toml: | [tls] # REQUIRED ca_cert = \"/etc/bpfd/certs/ca/ca.crt\" cert = \"/etc/bpfd/certs/bpfd/tls.crt\" key = \"/etc/bpfd/certs/bpfd/tls.key\" client_cert = \"/etc/bpfd/certs/bpfd-client/tls.crt\" client_key = \"/etc/bpfd/certs/bpfd-client/tls.key\" kind: ConfigMap metadata: annotations: kubectl.kubernetes.io/last-applied-configuration: | {\"apiVersion\":\"v1\",\"data\":{\"bpfd.agent.image\":\"quay.io/bpfd/bpfd-agent:main\",\"bpfd.image\":\"quay.io/bpfd/bpfd:main\",\"bpfd.log.level\":\"debug\",\"bpfd.na> creationTimestamp: \"2023-05-05T14:41:19Z\" name: bpfd-config namespace: bpfd resourceVersion: \"700803\" uid: 0cc04af4-032c-4712-b824-748b321d319b","title":"bpfd Daemonset"},{"location":"developer-guide/logging/#bpfd-operator","text":"The bpfd Operator is running as a Deployment with a ReplicaSet of one. It runs with the containers bpfd-operator and kube-rbac-proxy . To see the logs: kubectl logs -n bpfd bpfd-operator-7fbf4888c4-z8w76 -c bpfd-operator {\"level\":\"info\",\"ts\":\"2023-05-09T18:37:11Z\",\"logger\":\"controller-runtime.metrics\",\"msg\":\"Metrics server is starting to listen\",\"addr\":\"127.0.0.1:8080\"} {\"level\":\"info\",\"ts\":\"2023-05-09T18:37:11Z\",\"logger\":\"setup\",\"msg\":\"starting manager\"} {\"level\":\"info\",\"ts\":\"2023-05-09T18:37:11Z\",\"msg\":\"Starting server\",\"kind\":\"health probe\",\"addr\":\"[::]:8081\"} {\"level\":\"info\",\"ts\":\"2023-05-09T18:37:11Z\",\"msg\":\"Starting server\",\"path\":\"/metrics\",\"kind\":\"metrics\",\"addr\":\"127.0.0.1:8080\"} I0509 18:37:11.262885 1 leaderelection.go:248] attempting to acquire leader lease bpfd/8730d955.bpfd.io... I0509 18:37:11.268918 1 leaderelection.go:258] successfully acquired lease bpfd/8730d955.bpfd.io {\"level\":\"info\",\"ts\":\"2023-05-09T18:37:11Z\",\"msg\":\"Starting EventSource\",\"controller\":\"configmap\",\"controllerGroup\":\"\",\"controllerKind\":\"ConfigMap\",\"source\":\"kind source: *v1.ConfigMap\"} : kubectl logs -n bpfd bpfd-operator-7fbf4888c4-z8w76 -c kube-rbac-proxy I0509 18:37:11.063386 1 main.go:186] Valid token audiences: I0509 18:37:11.063485 1 main.go:316] Generating self signed cert as no cert is provided I0509 18:37:11.955256 1 main.go:366] Starting TCP socket on 0.0.0.0:8443 I0509 18:37:11.955849 1 main.go:373] Listening securely on 0.0.0.0:8443 To change the log level, edit the bpfd-operator Deployment. The change will get detected and the bpfd operator pod will get restarted with the updated log level. kubectl edit deployment -n bpfd bpfd-operator apiVersion: apps/v1 kind: Deployment metadata: annotations: deployment.kubernetes.io/revision: \"1\" kubectl.kubernetes.io/last-applied-configuration: | {\"apiVersion\":\"apps/v1\",\"kind\":\"Deployment\",\"metadata\":{\"annotations\":{},\"labels\":{\"app.kubernetes.io/component\":\"manager\",\"app.kubernetes.io/create> creationTimestamp: \"2023-05-09T18:37:08Z\" generation: 1 : spec: : template: metadata: : spec: containers: - args: : - args: - --health-probe-bind-address=:8081 - --metrics-bind-address=127.0.0.1:8080 - --leader-elect command: - /bpfd-operator env: - name: GO_LOG value: info <==== Set Log Level Here image: quay.io/bpfd/bpfd-operator:main imagePullPolicy: IfNotPresent :","title":"bpfd Operator"},{"location":"developer-guide/operator-quick-start/","text":"Deploying the bpfd-operator The bpfd-operator repository exists in order to deploy and manage bpfd within a Kubernetes cluster. Getting Started This operator was built utilizing some great tooling provided by the operator-sdk library . A great first step in understanding some of the functionality can be to just run make help . Deploy Locally via KIND After reviewing the possible make targets it's quick and easy to get bpfd deployed locally on your system via a KIND cluster with: make run-on-kind Deploy To Openshift Cluster First install cert-manager (if not already deployed) to the cluster with: make deploy-cert-manager Then deploy the operator with one of the following two options: 1. Manually with Kustomize To install manually with Kustomize and raw manifests simply run: make deploy-openshift Which can then be cleaned up with: make undeploy-openshift 2. Via the OLM bundle The bpfd-operator can also be installed via it's OLM bundle . First setup the namespace and certificates for the operator with: oc apply -f ./hack/ocp-scc-hacks.yaml Then use operator-sdk to install the bundle like so: operator-sdk run bundle quay.io/bpfd/bpfd-operator-bundle:latest --namespace openshift-bpfd To clean everything up run: operator-sdk cleanup bpfd-operator followed by oc delete -f ./hack/ocp-scc-hacks.yaml Verify the Installation If the bpfd-operator came up successfully you will see the bpfd-daemon and bpfd-operator pods running without errors: kubectl get pods -n bpfd NAME READY STATUS RESTARTS AGE bpfd-daemon-bt5xm 2 /2 Running 0 130m bpfd-daemon-ts7dr 2 /2 Running 0 129m bpfd-daemon-w24pr 2 /2 Running 0 130m bpfd-operator-78cf9c44c6-rv7f2 2 /2 Running 0 132m Deploy an eBPF Program to the cluster To test the deployment simply deploy one of the sample xdpPrograms : kubectl apply -f config/samples/bpfd.io_v1alpha1_xdp_pass_xdpprogram.yaml If loading of the XDP Program to the selected nodes was successful it will be reported back to the user via the xdpProgram 's status field: kubectl get xdpprogram xdp-pass-all-nodes -o yaml apiVersion: bpfd.io/v1alpha1 kind: XdpProgram metadata: creationTimestamp: \"2023-05-04T18:28:46Z\" finalizers: - bpfd.io.operator/finalizer generation: 1 labels: app.kubernetes.io/name: xdpprogram name: xdp-pass-all-nodes resourceVersion: \"11205\" uid: 8246b56c-b78e-43fc-bb78-3b46b1490a0c spec: bytecode: image: imagepullpolicy: IfNotPresent url: quay.io/bpfd-bytecode/xdp_pass:latest interfaceselector: primarynodeinterface: true nodeselector: {} priority: 0 proceedon: - pass - dispatcher_return sectionname: pass status: conditions: - lastTransitionTime: \"2023-05-04T18:28:46Z\" message: bpfProgramReconciliation Succeeded on all nodes reason: ReconcileSuccess status: \"True\" type: ReconcileSuccess kind: List metadata: resourceVersion: \"\" To see more information in listing form simply run: kubectl get xdpprogram -o wide NAME SECTIONNAME BYTECODE NODESELECTOR PRIORITY INTERFACESELECTOR PROCEEDON xdp-pass-all-nodes pass { \"image\" : { \"imagepullpolicy\" : \"IfNotPresent\" , \"url\" : \"quay.io/bpfd-bytecode/xdp_pass:latest\" }} {} 0 { \"primarynodeinterface\" :true } [ \"pass\" , \"dispatcher_return\" ] API Types Overview See api-spec.md for a more detailed description of all the bpfd Kubernetes API types. Multiple Program CRDs The multiple *Program CRDs are the bpfd Kubernetes API objects most relevant to users and can be used to understand clusterwide state for an eBPF program. It's designed to express how, and where eBPF programs are to be deployed within a Kubernetes cluster. Currently bpfd supports the use of xdpProgram , tcProgram and tracepointProgram objects. BpfProgram CRD The BpfProgram CRD is used internally by the bpfd-deployment to keep track of per node bpfd state such as map pin points, and to report node specific errors back to the user. Kubernetes users/controllers are only allowed to view these objects, NOT create or edit them. Applications wishing to use bpfd to deploy/manage their eBPF programs in Kubernetes will make use of this object to find references to the bpfMap pin points ( spec.maps ) in order to configure their eBPF programs.","title":"Deploying the bpfd-operator"},{"location":"developer-guide/operator-quick-start/#deploying-the-bpfd-operator","text":"The bpfd-operator repository exists in order to deploy and manage bpfd within a Kubernetes cluster.","title":"Deploying the bpfd-operator"},{"location":"developer-guide/operator-quick-start/#getting-started","text":"This operator was built utilizing some great tooling provided by the operator-sdk library . A great first step in understanding some of the functionality can be to just run make help .","title":"Getting Started"},{"location":"developer-guide/operator-quick-start/#deploy-locally-via-kind","text":"After reviewing the possible make targets it's quick and easy to get bpfd deployed locally on your system via a KIND cluster with: make run-on-kind","title":"Deploy Locally via KIND"},{"location":"developer-guide/operator-quick-start/#deploy-to-openshift-cluster","text":"First install cert-manager (if not already deployed) to the cluster with: make deploy-cert-manager Then deploy the operator with one of the following two options:","title":"Deploy To Openshift Cluster"},{"location":"developer-guide/operator-quick-start/#1-manually-with-kustomize","text":"To install manually with Kustomize and raw manifests simply run: make deploy-openshift Which can then be cleaned up with: make undeploy-openshift","title":"1. Manually with Kustomize"},{"location":"developer-guide/operator-quick-start/#2-via-the-olm-bundle","text":"The bpfd-operator can also be installed via it's OLM bundle . First setup the namespace and certificates for the operator with: oc apply -f ./hack/ocp-scc-hacks.yaml Then use operator-sdk to install the bundle like so: operator-sdk run bundle quay.io/bpfd/bpfd-operator-bundle:latest --namespace openshift-bpfd To clean everything up run: operator-sdk cleanup bpfd-operator followed by oc delete -f ./hack/ocp-scc-hacks.yaml","title":"2. Via the OLM bundle"},{"location":"developer-guide/operator-quick-start/#verify-the-installation","text":"If the bpfd-operator came up successfully you will see the bpfd-daemon and bpfd-operator pods running without errors: kubectl get pods -n bpfd NAME READY STATUS RESTARTS AGE bpfd-daemon-bt5xm 2 /2 Running 0 130m bpfd-daemon-ts7dr 2 /2 Running 0 129m bpfd-daemon-w24pr 2 /2 Running 0 130m bpfd-operator-78cf9c44c6-rv7f2 2 /2 Running 0 132m","title":"Verify the Installation"},{"location":"developer-guide/operator-quick-start/#deploy-an-ebpf-program-to-the-cluster","text":"To test the deployment simply deploy one of the sample xdpPrograms : kubectl apply -f config/samples/bpfd.io_v1alpha1_xdp_pass_xdpprogram.yaml If loading of the XDP Program to the selected nodes was successful it will be reported back to the user via the xdpProgram 's status field: kubectl get xdpprogram xdp-pass-all-nodes -o yaml apiVersion: bpfd.io/v1alpha1 kind: XdpProgram metadata: creationTimestamp: \"2023-05-04T18:28:46Z\" finalizers: - bpfd.io.operator/finalizer generation: 1 labels: app.kubernetes.io/name: xdpprogram name: xdp-pass-all-nodes resourceVersion: \"11205\" uid: 8246b56c-b78e-43fc-bb78-3b46b1490a0c spec: bytecode: image: imagepullpolicy: IfNotPresent url: quay.io/bpfd-bytecode/xdp_pass:latest interfaceselector: primarynodeinterface: true nodeselector: {} priority: 0 proceedon: - pass - dispatcher_return sectionname: pass status: conditions: - lastTransitionTime: \"2023-05-04T18:28:46Z\" message: bpfProgramReconciliation Succeeded on all nodes reason: ReconcileSuccess status: \"True\" type: ReconcileSuccess kind: List metadata: resourceVersion: \"\" To see more information in listing form simply run: kubectl get xdpprogram -o wide NAME SECTIONNAME BYTECODE NODESELECTOR PRIORITY INTERFACESELECTOR PROCEEDON xdp-pass-all-nodes pass { \"image\" : { \"imagepullpolicy\" : \"IfNotPresent\" , \"url\" : \"quay.io/bpfd-bytecode/xdp_pass:latest\" }} {} 0 { \"primarynodeinterface\" :true } [ \"pass\" , \"dispatcher_return\" ]","title":"Deploy an eBPF Program to the cluster"},{"location":"developer-guide/operator-quick-start/#api-types-overview","text":"See api-spec.md for a more detailed description of all the bpfd Kubernetes API types.","title":"API Types Overview"},{"location":"developer-guide/operator-quick-start/#multiple-program-crds","text":"The multiple *Program CRDs are the bpfd Kubernetes API objects most relevant to users and can be used to understand clusterwide state for an eBPF program. It's designed to express how, and where eBPF programs are to be deployed within a Kubernetes cluster. Currently bpfd supports the use of xdpProgram , tcProgram and tracepointProgram objects.","title":"Multiple Program CRDs"},{"location":"developer-guide/operator-quick-start/#bpfprogram-crd","text":"The BpfProgram CRD is used internally by the bpfd-deployment to keep track of per node bpfd state such as map pin points, and to report node specific errors back to the user. Kubernetes users/controllers are only allowed to view these objects, NOT create or edit them. Applications wishing to use bpfd to deploy/manage their eBPF programs in Kubernetes will make use of this object to find references to the bpfMap pin points ( spec.maps ) in order to configure their eBPF programs.","title":"BpfProgram CRD"},{"location":"developer-guide/shipping-bytecode/","text":"eBPF Bytecode Image Specifications Introduction The eBPF Bytecode Image specification defines how to package eBPF bytecode as container images. The initial primary use case focuses on the containerization and deployment of eBPF programs within container orchestration systems such as Kubernetes, where it is necessary to provide a portable way to distribute bytecode to all nodes which need it. Specifications We provide two distinct spec variants here to ensure interoperatiblity with existing registries and packages which do no support the new custom media types defined here. custom-data-type-spec backwards-compatable-spec Backwards compatible OCI compliant spec This variant makes use of existing OCI conventions to represent eBPF Bytecode as container images. Image Layers The container images following this variant must contain exactly one layer who's media type is one of the following: application/vnd.oci.image.layer.v1.tar+gzip or the compliant application/vnd.docker.image.rootfs.diff.tar.gzip Additionally the image layer must contain a valid eBPF object file (generally containing a .o extension) placed at the root of the layer ./ . Image Labels To provide relevant metadata regarding the bytecode to any consumers, some relevant labels MUST be defined on the image. These labels are defined as follows: io.ebpf.program_type : The eBPF program type (i.e xdp , tc , sockops , ...). io.ebpf.filename : The Filename of the bytecode stored in the image. io.ebpf.program_name : The name of the eBPF Program represented in the bytecode. io.ebpf.section_name : The section name of the eBPF Program. io.ebpf.kernel_version : The Kernel version for which this bytecode was compiled against. Building a Backwards compatible OCI compliant image An Example Containerfile can be found at /packaging/container/deployment/Containerfile.bytecode To use the provided templated Containerfile simply run a docker build command like the following: docker build \\ --build-arg PROGRAM_NAME = xdp_pass \\ --build-arg SECTION_NAME = pass \\ --build-arg PROGRAM_TYPE = xdp \\ --build-arg BYTECODE_FILENAME = pass.bpf.o \\ --build-arg KERNEL_COMPILE_VER = $( uname -r ) \\ -f packaging/container-deployment/Containerfile.bytecode \\ /home/<USER>/bytecode -t quay.io/<USER>/xdp_pass:latest Where /home/<USER>/bytecode is the directory the bytecode object file is located. Users can also use skopeo to ensure the image follows the backwards compatible version of the spec: skopeo inspect will show the correctly configured labels stored in the configuration layer ( application/vnd.oci.image.config.v1+json ) of the image. skopeo inspect docker://quay.io/astoycos/xdp_pass:latest { \"Name\" : \"quay.io/<USER>/xdp_pass\" , \"Digest\" : \"sha256:db1f7dd03f9fba0913e07493238fcfaf0bf08de37b8e992cc5902775dfb9086a\" , \"RepoTags\" : [ \"latest\" ] , \"Created\" : \"2022-08-14T14:27:20.147468277Z\" , \"DockerVersion\" : \"\" , \"Labels\" : { \"io.buildah.version\" : \"1.26.1\" , \"io.ebpf.filename\" : \"pass.bpf.o\" , \"io.ebpf.kernel_version\" : \"5.18.6-200.fc36.x86_64\" , \"io.ebpf.program_name\" : \"xdp_counter\" , \"io.ebpf.program_type\" : \"xdp\" , \"io.ebpf.section_name\" : \"pass\" } , \"Architecture\" : \"amd64\" , \"Os\" : \"linux\" , \"Layers\" : [ \"sha256:5f6dae6f567601fdad15a936d844baac1f30c31bd3df8df0c5b5429f3e048000\" ] , \"Env\" : [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" ] } skopeo inspect --raw will show the correct layer type is used in the image. skopeo inspect --raw docker://quay.io/astoycos/xdp_pass:latest { \"schemaVersion\" :2, \"mediaType\" : \"application/vnd.oci.image.manifest.v1+json\" , \"config\" : { \"mediaType\" : \"application/vnd.oci.image.config.v1+json\" , \"digest\" : \"sha256:ff4108b8405a877b2df3e06f9287c509b9d62d6c241c9a5213d81a9abee80361\" , \"size\" :2385 } , \"layers\" : [{ \"mediaType\" : \"application/vnd.oci.image.layer.v1.tar+gzip\" , \"digest\" : \"sha256:5f6dae6f567601fdad15a936d844baac1f30c31bd3df8df0c5b5429f3e048000\" , \"size\" :1539 }] , \"annotations\" : { \"org.opencontainers.image.base.digest\" : \"sha256:86b59a6cf7046c624c47e40a5618b383d763be712df2c0e7aaf9391c2c9ef559\" , \"org.opencontainers.image.base.name\" : \"\" }} Custom OCI compatible spec This variant of the eBPF bytecode image spec uses custom OCI medium types to represent eBPF bytecode as container images. Many toolchains and registries may not support this yet. TODO(astoycos)","title":"eBPF Bytecode Image Specifications"},{"location":"developer-guide/shipping-bytecode/#ebpf-bytecode-image-specifications","text":"","title":"eBPF Bytecode Image Specifications"},{"location":"developer-guide/shipping-bytecode/#introduction","text":"The eBPF Bytecode Image specification defines how to package eBPF bytecode as container images. The initial primary use case focuses on the containerization and deployment of eBPF programs within container orchestration systems such as Kubernetes, where it is necessary to provide a portable way to distribute bytecode to all nodes which need it.","title":"Introduction"},{"location":"developer-guide/shipping-bytecode/#specifications","text":"We provide two distinct spec variants here to ensure interoperatiblity with existing registries and packages which do no support the new custom media types defined here. custom-data-type-spec backwards-compatable-spec","title":"Specifications"},{"location":"developer-guide/shipping-bytecode/#backwards-compatible-oci-compliant-spec","text":"This variant makes use of existing OCI conventions to represent eBPF Bytecode as container images.","title":"Backwards compatible OCI compliant spec"},{"location":"developer-guide/shipping-bytecode/#image-layers","text":"The container images following this variant must contain exactly one layer who's media type is one of the following: application/vnd.oci.image.layer.v1.tar+gzip or the compliant application/vnd.docker.image.rootfs.diff.tar.gzip Additionally the image layer must contain a valid eBPF object file (generally containing a .o extension) placed at the root of the layer ./ .","title":"Image Layers"},{"location":"developer-guide/shipping-bytecode/#image-labels","text":"To provide relevant metadata regarding the bytecode to any consumers, some relevant labels MUST be defined on the image. These labels are defined as follows: io.ebpf.program_type : The eBPF program type (i.e xdp , tc , sockops , ...). io.ebpf.filename : The Filename of the bytecode stored in the image. io.ebpf.program_name : The name of the eBPF Program represented in the bytecode. io.ebpf.section_name : The section name of the eBPF Program. io.ebpf.kernel_version : The Kernel version for which this bytecode was compiled against.","title":"Image Labels"},{"location":"developer-guide/shipping-bytecode/#building-a-backwards-compatible-oci-compliant-image","text":"An Example Containerfile can be found at /packaging/container/deployment/Containerfile.bytecode To use the provided templated Containerfile simply run a docker build command like the following: docker build \\ --build-arg PROGRAM_NAME = xdp_pass \\ --build-arg SECTION_NAME = pass \\ --build-arg PROGRAM_TYPE = xdp \\ --build-arg BYTECODE_FILENAME = pass.bpf.o \\ --build-arg KERNEL_COMPILE_VER = $( uname -r ) \\ -f packaging/container-deployment/Containerfile.bytecode \\ /home/<USER>/bytecode -t quay.io/<USER>/xdp_pass:latest Where /home/<USER>/bytecode is the directory the bytecode object file is located. Users can also use skopeo to ensure the image follows the backwards compatible version of the spec: skopeo inspect will show the correctly configured labels stored in the configuration layer ( application/vnd.oci.image.config.v1+json ) of the image. skopeo inspect docker://quay.io/astoycos/xdp_pass:latest { \"Name\" : \"quay.io/<USER>/xdp_pass\" , \"Digest\" : \"sha256:db1f7dd03f9fba0913e07493238fcfaf0bf08de37b8e992cc5902775dfb9086a\" , \"RepoTags\" : [ \"latest\" ] , \"Created\" : \"2022-08-14T14:27:20.147468277Z\" , \"DockerVersion\" : \"\" , \"Labels\" : { \"io.buildah.version\" : \"1.26.1\" , \"io.ebpf.filename\" : \"pass.bpf.o\" , \"io.ebpf.kernel_version\" : \"5.18.6-200.fc36.x86_64\" , \"io.ebpf.program_name\" : \"xdp_counter\" , \"io.ebpf.program_type\" : \"xdp\" , \"io.ebpf.section_name\" : \"pass\" } , \"Architecture\" : \"amd64\" , \"Os\" : \"linux\" , \"Layers\" : [ \"sha256:5f6dae6f567601fdad15a936d844baac1f30c31bd3df8df0c5b5429f3e048000\" ] , \"Env\" : [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" ] } skopeo inspect --raw will show the correct layer type is used in the image. skopeo inspect --raw docker://quay.io/astoycos/xdp_pass:latest { \"schemaVersion\" :2, \"mediaType\" : \"application/vnd.oci.image.manifest.v1+json\" , \"config\" : { \"mediaType\" : \"application/vnd.oci.image.config.v1+json\" , \"digest\" : \"sha256:ff4108b8405a877b2df3e06f9287c509b9d62d6c241c9a5213d81a9abee80361\" , \"size\" :2385 } , \"layers\" : [{ \"mediaType\" : \"application/vnd.oci.image.layer.v1.tar+gzip\" , \"digest\" : \"sha256:5f6dae6f567601fdad15a936d844baac1f30c31bd3df8df0c5b5429f3e048000\" , \"size\" :1539 }] , \"annotations\" : { \"org.opencontainers.image.base.digest\" : \"sha256:86b59a6cf7046c624c47e40a5618b383d763be712df2c0e7aaf9391c2c9ef559\" , \"org.opencontainers.image.base.name\" : \"\" }}","title":"Building a Backwards compatible OCI compliant image"},{"location":"developer-guide/shipping-bytecode/#custom-oci-compatible-spec","text":"This variant of the eBPF bytecode image spec uses custom OCI medium types to represent eBPF bytecode as container images. Many toolchains and registries may not support this yet. TODO(astoycos)","title":"Custom OCI compatible spec"},{"location":"getting-started/bpfctl-guide/","text":"bpfctl Guide bpfctl is the command line tool for interacting with bpfd . bpfctl allows the user to load , unload and list eBPF programs. Notes For This Guide As described in other sections, bpfd can be run as either a privileged process or a systemd service. If run as a privileged process, bpfctl will most likely be run from your local development branch and will require sudo . Example: sudo ./target/debug/bpfctl list If run as a systemd service, bpfctl will most likely be installed in your $PATH, the bpfd user and user group were created, so the usergroup bpfd will need to be added to the desired user. Then sudo is no longer required. Example: sudo usermod -a -G bpfd $USER exit <LOGIN> bpfctl list The examples here use bpfctl in place of sudo ./target/debug/bpfctl for readability, use as your system is deployed. bpfctl load-from-file With bpfd As A Systemd Service For security reasons, when bpfd is run as a systemd service, all linux capabilities are stripped from any spawned threads. Therefore, bpfd can only access files owned by the bpfd user group. This includes eBPF object files. In the bpfctl load-from-file examples below, the files are located in /run/bpfd/examples/ , which is a directory owned by bpfd . Below is an example of copying local files over for use in this scenario: sudo cp /$HOME/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o /run/bpfd/examples/. sudo cp /$HOME/src/net-ebpf-playground/.output/filter.bpf.o /run/bpfd/examples/. sudo chown bpfd:bpfd -R /run/bpfd/examples/ This is only needed if bpfd is run as a systemd service. Basic Syntax Below are the commands supported by bpfctl . bpfctl --help A client for working with bpfd Usage: bpfctl <COMMAND> Commands: load-from-file Load an eBPF program from a local .o file load-from-image Load an eBPF program packaged in a OCI container image from a given registry unload Unload an eBPF program using the UUID list List all eBPF programs loaded via bpfd help Print this message or the help of the given subcommand(s) Options: -h, --help Print help information -V, --version Print version information bpfctl load The bpfctl load-from-file and bpfctl load-from-image commands are used to load eBPF programs. Each program type (i.e. <COMMAND> ) has it's own set of attributes specific to the program type, and those attributes MUST come after the program type is entered. There are a common set of attributes, and those MUST come before the program type is entered. bpfctl load-from-file --help Load an eBPF program from a local .o file Usage: bpfctl load-from-file [OPTIONS] --path <PATH> --section-name <SECTION_NAME> <COMMAND> Commands: xdp Install an eBPF program on an XDP hook point for a given interface tc Install an eBPF program on a TC hook point for a given interface tracepoint Install an eBPF program on a Tracepoint help Print this message or the help of the given subcommand(s) Options: -p, --path <PATH> Required: Location of Local bytecode file Example: --path /run/bpfd/examples/go-xdp-counter/bpf_bpfel.o -s, --section-name <SECTION_NAME> Required: Name of the ELF section from the object file --id <ID> Optional: Program uuid to be used by bpfd. If not specified, bpfd will generate a uuid. -g, --global <GLOBAL>... Optional: Global variables to be set when program is loaded. Format: <NAME>=<Hex Value> This is a very low level primitive. The caller is responsible for formatting the byte string appropriately considering such things as size, endianness, alignment and packing of data structures. -h, --help Print help (see a summary with '-h') So when using bpfctl load-from-file , --path , --section-name , --id and --global must be entered before the <COMMAND> ( xdp , tc or tracepoint ) is entered. Then each <COMMAND> has it's own custom parameters: bpfctl load-from-file xdp --help Install an eBPF program on an XDP hook point for a given interface Usage: bpfctl load-from-file --path <PATH> --section-name <SECTION_NAME> xdp [OPTIONS] --iface <IFACE> --priority <PRIORITY> Options: -i, --iface <IFACE> Required: Interface to load program on -p, --priority <PRIORITY> Required: Priority to run program in chain. Lower value runs first --proceed-on <PROCEED_ON>... Optional: Proceed to call other programs in chain on this exit code. Multiple values supported by repeating the parameter. Valid values: [aborted, drop, pass, tx, redirect, dispatcher_return] Example: --proceed-on \"pass\" --proceed-on \"drop\" [default: pass, dispatcher_return] -h, --help Print help Example loading from local file: bpfctl load-from-file --path /run/bpfd/examples/xdp_pass_kern.o --section-name \"xdp\" xdp --iface vethb2795c7 --priority 100 Example from image in remote repository (Note: --section-name is built into the image and is not required): bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 100 bpfctl Load Examples Below are some examples of bpfctl load commands: bpfctl load-from-file --path /run/bpfd/examples/xdp_pass_kern.o --section-name \"xdp\" xdp --iface vethb2795c7 --priority 35 bpfctl load-from-file --path /run/bpfd/examples/filter.bpf.o --section-name classifier tc --direction ingress --iface vethb2795c7 --priority 110 bpfctl load-from-image --image-url quay.io/bpfd-bytecode/tracepoint:latest tracepoint --tracepoint sched/sched_switch bpfctl list The bpfctl list command lists all the loaded eBPF programs: bpfctl list UUID Type Name Location Metadata 9d37c6c7-d988-41da-ac89-200655f61584 xdp xdp file: { path: /run/bpfd/examples/xdp_pass_kern.o } { priority: 35, iface: vethb2795c7, position: 0, proceed_on: pass, dispatcher_return } c1e8691e-bfd7-48a7-bdeb-e2b429bfc2f4 tracepoint hello image: { url: quay.io/bpfd-bytecode/tracepoint:latest, pullpolicy: IfNotPresent } { tracepoint: sched/sched_switch } 84eff4d7-6dbb-4ed7-9ce4-d6b5478e8d91 tc classifier file: { path: /run/bpfd/examples/filter.bpf.o } { priority: 110, iface: vethb2795c7, position: 0, direction: in, proceed_on: pipe, dispatcher_return } bpfctl unload The bpfctl unload command takes the UUID from the load or list command as a parameter, and unloads the requested eBPF program: bpfctl unload 84eff4d7-6dbb-4ed7-9ce4-d6b5478e8d91 bpfctl list UUID Type Name Location Metadata 9d37c6c7-d988-41da-ac89-200655f61584 xdp xdp file: { path: /run/bpfd/examples/xdp_pass_kern.o } { priority: 35, iface: vethb2795c7, position: 0, proceed_on: pass, dispatcher_return } c1e8691e-bfd7-48a7-bdeb-e2b429bfc2f4 tracepoint hello image: { url: quay.io/bpfd-bytecode/tracepoint:latest, pullpolicy: IfNotPresent } { tracepoint: sched/sched_switch } dispatcher_return }","title":"bpfctl Guide"},{"location":"getting-started/bpfctl-guide/#bpfctl-guide","text":"bpfctl is the command line tool for interacting with bpfd . bpfctl allows the user to load , unload and list eBPF programs.","title":"bpfctl Guide"},{"location":"getting-started/bpfctl-guide/#notes-for-this-guide","text":"As described in other sections, bpfd can be run as either a privileged process or a systemd service. If run as a privileged process, bpfctl will most likely be run from your local development branch and will require sudo . Example: sudo ./target/debug/bpfctl list If run as a systemd service, bpfctl will most likely be installed in your $PATH, the bpfd user and user group were created, so the usergroup bpfd will need to be added to the desired user. Then sudo is no longer required. Example: sudo usermod -a -G bpfd $USER exit <LOGIN> bpfctl list The examples here use bpfctl in place of sudo ./target/debug/bpfctl for readability, use as your system is deployed.","title":"Notes For This Guide"},{"location":"getting-started/bpfctl-guide/#bpfctl-load-from-file-with-bpfd-as-a-systemd-service","text":"For security reasons, when bpfd is run as a systemd service, all linux capabilities are stripped from any spawned threads. Therefore, bpfd can only access files owned by the bpfd user group. This includes eBPF object files. In the bpfctl load-from-file examples below, the files are located in /run/bpfd/examples/ , which is a directory owned by bpfd . Below is an example of copying local files over for use in this scenario: sudo cp /$HOME/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o /run/bpfd/examples/. sudo cp /$HOME/src/net-ebpf-playground/.output/filter.bpf.o /run/bpfd/examples/. sudo chown bpfd:bpfd -R /run/bpfd/examples/ This is only needed if bpfd is run as a systemd service.","title":"bpfctl load-from-file With bpfd As A Systemd Service"},{"location":"getting-started/bpfctl-guide/#basic-syntax","text":"Below are the commands supported by bpfctl . bpfctl --help A client for working with bpfd Usage: bpfctl <COMMAND> Commands: load-from-file Load an eBPF program from a local .o file load-from-image Load an eBPF program packaged in a OCI container image from a given registry unload Unload an eBPF program using the UUID list List all eBPF programs loaded via bpfd help Print this message or the help of the given subcommand(s) Options: -h, --help Print help information -V, --version Print version information","title":"Basic Syntax"},{"location":"getting-started/bpfctl-guide/#bpfctl-load","text":"The bpfctl load-from-file and bpfctl load-from-image commands are used to load eBPF programs. Each program type (i.e. <COMMAND> ) has it's own set of attributes specific to the program type, and those attributes MUST come after the program type is entered. There are a common set of attributes, and those MUST come before the program type is entered. bpfctl load-from-file --help Load an eBPF program from a local .o file Usage: bpfctl load-from-file [OPTIONS] --path <PATH> --section-name <SECTION_NAME> <COMMAND> Commands: xdp Install an eBPF program on an XDP hook point for a given interface tc Install an eBPF program on a TC hook point for a given interface tracepoint Install an eBPF program on a Tracepoint help Print this message or the help of the given subcommand(s) Options: -p, --path <PATH> Required: Location of Local bytecode file Example: --path /run/bpfd/examples/go-xdp-counter/bpf_bpfel.o -s, --section-name <SECTION_NAME> Required: Name of the ELF section from the object file --id <ID> Optional: Program uuid to be used by bpfd. If not specified, bpfd will generate a uuid. -g, --global <GLOBAL>... Optional: Global variables to be set when program is loaded. Format: <NAME>=<Hex Value> This is a very low level primitive. The caller is responsible for formatting the byte string appropriately considering such things as size, endianness, alignment and packing of data structures. -h, --help Print help (see a summary with '-h') So when using bpfctl load-from-file , --path , --section-name , --id and --global must be entered before the <COMMAND> ( xdp , tc or tracepoint ) is entered. Then each <COMMAND> has it's own custom parameters: bpfctl load-from-file xdp --help Install an eBPF program on an XDP hook point for a given interface Usage: bpfctl load-from-file --path <PATH> --section-name <SECTION_NAME> xdp [OPTIONS] --iface <IFACE> --priority <PRIORITY> Options: -i, --iface <IFACE> Required: Interface to load program on -p, --priority <PRIORITY> Required: Priority to run program in chain. Lower value runs first --proceed-on <PROCEED_ON>... Optional: Proceed to call other programs in chain on this exit code. Multiple values supported by repeating the parameter. Valid values: [aborted, drop, pass, tx, redirect, dispatcher_return] Example: --proceed-on \"pass\" --proceed-on \"drop\" [default: pass, dispatcher_return] -h, --help Print help Example loading from local file: bpfctl load-from-file --path /run/bpfd/examples/xdp_pass_kern.o --section-name \"xdp\" xdp --iface vethb2795c7 --priority 100 Example from image in remote repository (Note: --section-name is built into the image and is not required): bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 100","title":"bpfctl load"},{"location":"getting-started/bpfctl-guide/#bpfctl-load-examples","text":"Below are some examples of bpfctl load commands: bpfctl load-from-file --path /run/bpfd/examples/xdp_pass_kern.o --section-name \"xdp\" xdp --iface vethb2795c7 --priority 35 bpfctl load-from-file --path /run/bpfd/examples/filter.bpf.o --section-name classifier tc --direction ingress --iface vethb2795c7 --priority 110 bpfctl load-from-image --image-url quay.io/bpfd-bytecode/tracepoint:latest tracepoint --tracepoint sched/sched_switch","title":"bpfctl Load Examples"},{"location":"getting-started/bpfctl-guide/#bpfctl-list","text":"The bpfctl list command lists all the loaded eBPF programs: bpfctl list UUID Type Name Location Metadata 9d37c6c7-d988-41da-ac89-200655f61584 xdp xdp file: { path: /run/bpfd/examples/xdp_pass_kern.o } { priority: 35, iface: vethb2795c7, position: 0, proceed_on: pass, dispatcher_return } c1e8691e-bfd7-48a7-bdeb-e2b429bfc2f4 tracepoint hello image: { url: quay.io/bpfd-bytecode/tracepoint:latest, pullpolicy: IfNotPresent } { tracepoint: sched/sched_switch } 84eff4d7-6dbb-4ed7-9ce4-d6b5478e8d91 tc classifier file: { path: /run/bpfd/examples/filter.bpf.o } { priority: 110, iface: vethb2795c7, position: 0, direction: in, proceed_on: pipe, dispatcher_return }","title":"bpfctl list"},{"location":"getting-started/bpfctl-guide/#bpfctl-unload","text":"The bpfctl unload command takes the UUID from the load or list command as a parameter, and unloads the requested eBPF program: bpfctl unload 84eff4d7-6dbb-4ed7-9ce4-d6b5478e8d91 bpfctl list UUID Type Name Location Metadata 9d37c6c7-d988-41da-ac89-200655f61584 xdp xdp file: { path: /run/bpfd/examples/xdp_pass_kern.o } { priority: 35, iface: vethb2795c7, position: 0, proceed_on: pass, dispatcher_return } c1e8691e-bfd7-48a7-bdeb-e2b429bfc2f4 tracepoint hello image: { url: quay.io/bpfd-bytecode/tracepoint:latest, pullpolicy: IfNotPresent } { tracepoint: sched/sched_switch } dispatcher_return }","title":"bpfctl unload"},{"location":"getting-started/building-bpfd/","text":"Setup and Building bpfd This section describes how to build bpfd. If this is the first time building bpfd, jump to the Development Environment Setup section for help installing the tooling. Building bpfd To just test with the latest bpfd, containerized image are stored in quay.io/bpfd (see bpfd Container Images ). To build with local changes, use the following commands. If you are building bpfd for the first time OR the eBPF code has changed: cargo xtask build-ebpf --libbpf-dir /path/to/libbpf If protobuf files have changed: cargo xtask build-proto To build bpfd and bpfctl: cargo build Development Environment Setup To build bpfd, the following packages must be installed. Install Rust Toolchain For further detailed instructions, see Rust Stable & Rust Nightly . curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh export PATH=\"$HOME/.cargo/bin:$PATH\" rustup toolchain install nightly -c rustfmt,clippy,rust-src Install LLVM LLVM 11 or later must be installed. Linux package managers should provide a recent enough release. dnf based OS: sudo dnf install llvm-devel clang-devel elfutils-libelf-devel apt based OS: sudo apt install clang lldb lld libelf-dev gcc-multilib Install Protobuf Compiler For further detailed instructions, see protoc . dnf based OS: sudo dnf install protobuf-compiler apt based OS: sudo apt install protobuf-compiler Install GO protobuf Compiler Extensions See Quick Start Guide for gRPC in Go for installation instructions. Local libbpf Checkout a local copy of libbpf. git clone https://github.com/libbpf/libbpf --branch v0.8.0 Install perl Install perl : dnf based OS: sudo dnf install perl apt based OS: sudo apt install perl","title":"Setup and Building"},{"location":"getting-started/building-bpfd/#setup-and-building-bpfd","text":"This section describes how to build bpfd. If this is the first time building bpfd, jump to the Development Environment Setup section for help installing the tooling.","title":"Setup and Building bpfd"},{"location":"getting-started/building-bpfd/#building-bpfd","text":"To just test with the latest bpfd, containerized image are stored in quay.io/bpfd (see bpfd Container Images ). To build with local changes, use the following commands. If you are building bpfd for the first time OR the eBPF code has changed: cargo xtask build-ebpf --libbpf-dir /path/to/libbpf If protobuf files have changed: cargo xtask build-proto To build bpfd and bpfctl: cargo build","title":"Building bpfd"},{"location":"getting-started/building-bpfd/#development-environment-setup","text":"To build bpfd, the following packages must be installed.","title":"Development Environment Setup"},{"location":"getting-started/building-bpfd/#install-rust-toolchain","text":"For further detailed instructions, see Rust Stable & Rust Nightly . curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh export PATH=\"$HOME/.cargo/bin:$PATH\" rustup toolchain install nightly -c rustfmt,clippy,rust-src","title":"Install Rust Toolchain"},{"location":"getting-started/building-bpfd/#install-llvm","text":"LLVM 11 or later must be installed. Linux package managers should provide a recent enough release. dnf based OS: sudo dnf install llvm-devel clang-devel elfutils-libelf-devel apt based OS: sudo apt install clang lldb lld libelf-dev gcc-multilib","title":"Install LLVM"},{"location":"getting-started/building-bpfd/#install-protobuf-compiler","text":"For further detailed instructions, see protoc . dnf based OS: sudo dnf install protobuf-compiler apt based OS: sudo apt install protobuf-compiler","title":"Install Protobuf Compiler"},{"location":"getting-started/building-bpfd/#install-go-protobuf-compiler-extensions","text":"See Quick Start Guide for gRPC in Go for installation instructions.","title":"Install GO protobuf Compiler Extensions"},{"location":"getting-started/building-bpfd/#local-libbpf","text":"Checkout a local copy of libbpf. git clone https://github.com/libbpf/libbpf --branch v0.8.0","title":"Local libbpf"},{"location":"getting-started/building-bpfd/#install-perl","text":"Install perl : dnf based OS: sudo dnf install perl apt based OS: sudo apt install perl","title":"Install perl"},{"location":"getting-started/example-bpf-k8s/","text":"Deploying Example eBPF Programs On Kubernetes This section will describe loading bytecode on a Kubernetes cluster and launching the userspace program. The approach is slightly different when running on a Kubernetes cluster. The eBPF bytecode should be loaded by an administrator, not the userspace program itself. This section assumes there is already a Kubernetes cluster running and bpfd is running in the cluster. See Deploying the bpfd-operator for details on deploying bpfd on a Kubernetes cluster, but the quickest solution is to run a Kubernetes KIND Cluster: cd bpfd/bpfd-operator/ make run-on-kind Loading eBPF Bytecode On Kubernetes Instead of using the userspace program or bpfctl to load the eBPF bytecode as done in previous sections, the bytecode will be loaded by creating a Kubernetes CRD object. There is a CRD object for each eBPF program type bpfd supports. Edit the sample yaml files to customize any configuration values: TcProgram CRD: go-tc-counter-bytecode.yaml TracepointProgram CRD: go-tracepoint-counter-bytecode.yaml XdpProgram CRD: go-xdp-counter-bytecode.yaml Sample bytecode yaml with XdpProgram CRD: vi examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter-bytecode.yaml apiVersion: bpfd.io/v1alpha1 kind: XdpProgram metadata: labels: app.kubernetes.io/name: xdpprogram name: go-xdp-counter-example spec: sectionname: stats # Select all nodes nodeselector: {} interfaceselector: primarynodeinterface: true priority: 55 bytecode: image: url: quay.io/bpfd-bytecode/go-xdp-counter:latest Note that all the sample yaml files are configured with the bytecode running on all nodes ( nodeselector: {} ). This can be change to run on specific nodes, but the DaemonSet yaml for the userspace program, which is described below, should have an equivalent change. Make any changes to the go-xdp-counter-bytecode.yaml , then repeat for go-tc-counter-bytecode.yaml and go-tracepoint-counter-bytecode.yaml and then apply the updated yamls: kubectl apply -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter-bytecode.yaml xdpprogram.bpfd.io/go-xdp-counter-example created kubectl apply -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter-bytecode.yaml tcprogram.bpfd.io/go-tc-counter-example created kubectl apply -f examples/go-tracepoint-counter/kubernetes-deployment/go-tracepoint-counter-bytecode.yaml tracepointprogram.bpfd.io/go-tracepoint-counter-example created Following the diagram for XDP example (Blue numbers): The user creates a XdpProgram object with the parameters associated with the eBPF bytecode, like interface, priority and BFP bytecode image. The name of the XdpProgram object in this example is go-xdp-counter-example . bpfd-agent , running on each node, is watching for all changes to XdpProgram objects. When it sees a XdpProgram object created or modified, it makes sure a BpfProgram object for that node exists. The name of the BpfProgram object is the XdpProgram object name with the node name appended. bpfd-agent then determines if it should be running on the given node, loads or unloads as needed by making gRPC calls the bpfd . bpfd behaves the same as described in the running locally example. bpfd-agent finally updates the status of the BpfProgram object. bpfd-operator watches all BpfProgram objects, and updates the status of the XdpProgram object indicating if the eBPF program has been applied to all the desired nodes or not. To retrieve information on the XdpProgram objects: kubectl get xdpprograms NAME PRIORITY DIRECTION go-xdp-counter-example 55 kubectl get xdpprograms go-xdp-counter-example -o yaml apiVersion: bpfd.io/v1alpha1 kind: XdpProgram metadata: creationTimestamp: \"2023-05-04T15:41:45Z\" finalizers: - bpfd.io.operator/finalizer generation: 1 labels: app.kubernetes.io/name: xdpprogram name: go-xdp-counter-example resourceVersion: \"1786\" uid: 19a64cf8-3909-4a61-a5c0-5a3ddb95769c spec: bytecode: image: imagepullpolicy: IfNotPresent url: quay.io/bpfd-bytecode/go-xdp-counter:latest interfaceselector: primarynodeinterface: true nodeselector: {} priority: 55 proceedon: - pass - dispatcher_return sectionname: stats status: conditions: - lastTransitionTime: \"2023-05-04T15:41:45Z\" message: Waiting for BpfProgramConfig Object to be reconciled to all nodes reason: ProgramsNotYetLoaded status: \"True\" type: NotYetLoaded - lastTransitionTime: \"2023-05-04T15:41:45Z\" message: bpfProgramReconciliation Succeeded on all nodes reason: ReconcileSuccess status: \"True\" type: ReconcileSuccess To retrieve information on the BpfProgram objects: kubectl get bpfprograms NAME AGE go-tc-counter-example-bpfd-deployment-control-plane 8m52s go-tc-counter-example-bpfd-deployment-worker 8m53s go-tc-counter-example-bpfd-deployment-worker2 8m53s go-tracepoint-counter-example-bpfd-deployment-control-plane 8m52s go-tracepoint-counter-example-bpfd-deployment-worker 8m53s go-tracepoint-counter-example-bpfd-deployment-worker2 8m53s go-xdp-counter-example-bpfd-deployment-control-plane 8m54s go-xdp-counter-example-bpfd-deployment-worker 8m54s go-xdp-counter-example-bpfd-deployment-worker2 8m54s kubectl get bpfprograms go-xdp-counter-example-bpfd-deployment-worker -o yaml apiVersion: bpfd.io/v1alpha1 kind: BpfProgram metadata: creationTimestamp: \"2023-05-04T15:41:45Z\" finalizers: - bpfd.io.xdpprogramcontroller-finalizer generation: 2 labels: ownedByProgram: go-xdp-counter-example name: go-xdp-counter-example-bpfd-deployment-worker ownerReferences: - apiVersion: bpfd.io/v1alpha1 blockOwnerDeletion: true controller: true kind: XdpProgram name: go-xdp-counter-example uid: 19a64cf8-3909-4a61-a5c0-5a3ddb95769c resourceVersion: \"1869\" uid: 93a0f736-4a7a-48c2-b6ff-bc715b3580d6 spec: node: bpfd-deployment-worker programs: ff121084-1211-4fa4-bb16-ddd18e3c63d5: xdp_stats_map: /run/bpfd/fs/maps/ff121084-1211-4fa4-bb16-ddd18e3c63d5/xdp_stats_map type: xdp status: conditions: - lastTransitionTime: \"2023-05-04T15:41:46Z\" message: Successfully loaded bpfProgram reason: bpfdLoaded status: \"True\" type: Loaded Loading Userspace Container On Kubernetes Loading A Userspace Container Image The userspace programs have been pre-built and can be found here: quay.io/bpfd-userspace/go-tc-counter:latest quay.io/bpfd-userspace/go-tracepoint-counter:latest quay.io/bpfd-userspace/go-xdp-counter:latest The example yaml files below are loading from these image. go-tc-counter.yaml go-tracepoint-counter.yaml go-xdp-counter.yaml The userspace program in a Kubernetes Deployment no longer interacts directly with bpfd . Instead, the userspace program running on each node reads the BpfProgram to determine the map location. For example, the output above shows the maps as: kubectl get bpfprograms go-xdp-counter-example-bpfd-deployment-worker -o yaml : spec: node: bpfd-deployment-worker programs: ff121084-1211-4fa4-bb16-ddd18e3c63d5: xdp_stats_map: /run/bpfd/fs/maps/ff121084-1211-4fa4-bb16-ddd18e3c63d5/xdp_stats_map type: xdp : To interact with the KubeApiServer, RBAC must be setup properly to access the BpfProgram object. The bpfd-operator defined the yaml for several ClusterRoles that can be used to access the different bpfd related CRD objects with different access rights. The example userspace containers will use the bpfprogram-viewer-role , which allows Read-Only access to the BpfProgram object. This ClusterRole is created automatically by the bpfd-operator . The remaining objects (NameSpace, ServiceAccount, ClusterRoleBinding and examples DaemonSet) also need to be created. cd bpfd/ kubectl create -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter.yaml kubectl create -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter.yaml kubectl create -f examples/go-tracepoint-counter/kubernetes-deployment/go-tracepoint-counter.yaml Following the diagram for the XDP example (Green numbers): The userspace program queries the KubeApiServer for a specific BpfProgram object. The userspace program pulls the file location of the shared map out of the BpfProgram object and uses the file to periodically read the counter values. To see if the userspace programs are working, view the logs: kubectl get pods -A NAMESPACE NAME READY STATUS RESTARTS AGE : go-tc-counter go-tc-counter-ds-2dfn8 1/1 Running 0 16m go-tc-counter go-tc-counter-ds-mn82s 1/1 Running 0 16m go-tc-counter go-tc-counter-ds-qbf9w 1/1 Running 0 16m go-tracepoint-counter go-tracepoint-counter-ds-686g5 1/1 Running 0 16m go-tracepoint-counter go-tracepoint-counter-ds-tzj2r 1/1 Running 0 16m go-tracepoint-counter go-tracepoint-counter-ds-zfz6k 1/1 Running 0 16m go-xdp-counter go-xdp-counter-ds-c626t 1/1 Running 0 16m go-xdp-counter go-xdp-counter-ds-kskgh 1/1 Running 0 16m go-xdp-counter go-xdp-counter-ds-xx6dp 1/1 Running 0 16m : kubectl logs -n go-xdp-counter go-xdp-counter-ds-5q4hz 2023/01/08 08:47:55 908748 packets received 2023/01/08 08:47:55 631463477 bytes received 2023/01/08 08:47:58 908757 packets received 2023/01/08 08:47:58 631466099 bytes received 2023/01/08 08:48:01 908778 packets received 2023/01/08 08:48:01 631472201 bytes received 2023/01/08 08:48:04 908791 packets received 2023/01/08 08:48:04 631480013 bytes received : To cleanup: kubectl delete -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter.yaml kubectl delete -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter-bytecode.yaml kubectl delete -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter.yaml kubectl delete -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter-bytecode.yaml kubectl delete -f examples/go-tracepoint-counter/kubernetes-deployment/go-tracepoint-counter.yaml kubectl delete -f examples/go-tracepoint-counter/kubernetes-deployment/go-tracepoint-counter-bytecode.yaml There are two scripts that will automate the steps described above: cd bpfd ./scripts/cr-k8s-examples.sh xdpprogram.bpfd.io/go-xdp-counter-example created namespace/go-xdp-counter created serviceaccount/bpfd-app-go-xdp-counter created clusterrolebinding.rbac.authorization.k8s.io/privileged-scc created clusterrolebinding.rbac.authorization.k8s.io/bpfd-app-rolebinding-go-xdp-counter created daemonset.apps/go-xdp-counter-ds created tcprogram.bpfd.io/go-tc-counter-example created namespace/go-tc-counter created serviceaccount/bpfd-app-go-tc-counter created clusterrolebinding.rbac.authorization.k8s.io/bpfd-app-rolebinding-go-tc-counter created daemonset.apps/go-tc-counter-ds created tracepointprogram.bpfd.io/go-tracepoint-counter-example created namespace/go-tracepoint-counter created serviceaccount/bpfd-app-go-tracepoint-counter created clusterrolebinding.rbac.authorization.k8s.io/bpfd-app-rolebinding-go-tracepoint-counter created daemonset.apps/go-tracepoint-counter-ds created # Test Away ... ./scripts/del-k8s-examples.sh serviceaccount \"bpfd-app-go-xdp-counter\" deleted clusterrolebinding.rbac.authorization.k8s.io \"privileged-scc\" deleted clusterrolebinding.rbac.authorization.k8s.io \"bpfd-app-rolebinding-go-xdp-counter\" deleted daemonset.apps \"go-xdp-counter-ds\" deleted xdpprogram.bpfd.io \"go-xdp-counter-example\" deleted namespace \"go-tc-counter\" deleted serviceaccount \"bpfd-app-go-tc-counter\" deleted clusterrolebinding.rbac.authorization.k8s.io \"bpfd-app-rolebinding-go-tc-counter\" deleted daemonset.apps \"go-tc-counter-ds\" deleted tcprogram.bpfd.io \"go-tc-counter-example\" deleted namespace \"go-tracepoint-counter\" deleted serviceaccount \"bpfd-app-go-tracepoint-counter\" deleted clusterrolebinding.rbac.authorization.k8s.io \"bpfd-app-rolebinding-go-tracepoint-counter\" deleted daemonset.apps \"go-tracepoint-counter-ds\" deleted tracepointprogram.bpfd.io \"go-tracepoint-counter-example\" deleted Building A Userspace Container Image To build the userspace examples in a container instead of using the pre-built ones, from the bpfd code source directory, run the following build commands: cd bpfd/ docker build -f examples/go-xdp-counter/container-deployment/Containerfile.go-xdp-counter . -t quay.io/$USER/go-xdp-counter:latest docker build -f examples/go-tc-counter/container-deployment/Containerfile.go-tc-counter . -t quay.io/$USER/go-tc-counter:latest docker build -f examples/go-tracepoint-counter/container-deployment/Containerfile.go-tracepoint-counter . -t quay.io/$USER/go-tracepoint-counter:latest Then push images to a remote repository: docker login quay.io docker push quay.io/$USER/go-xdp-counter:latest docker push quay.io/$USER/go-tc-counter:latest docker push quay.io/$USER/go-tracepoint-counter:latest Update the yaml to use the private images.","title":"Deploying Example eBPF Programs On Kubernetes"},{"location":"getting-started/example-bpf-k8s/#deploying-example-ebpf-programs-on-kubernetes","text":"This section will describe loading bytecode on a Kubernetes cluster and launching the userspace program. The approach is slightly different when running on a Kubernetes cluster. The eBPF bytecode should be loaded by an administrator, not the userspace program itself. This section assumes there is already a Kubernetes cluster running and bpfd is running in the cluster. See Deploying the bpfd-operator for details on deploying bpfd on a Kubernetes cluster, but the quickest solution is to run a Kubernetes KIND Cluster: cd bpfd/bpfd-operator/ make run-on-kind","title":"Deploying Example eBPF Programs On Kubernetes"},{"location":"getting-started/example-bpf-k8s/#loading-ebpf-bytecode-on-kubernetes","text":"Instead of using the userspace program or bpfctl to load the eBPF bytecode as done in previous sections, the bytecode will be loaded by creating a Kubernetes CRD object. There is a CRD object for each eBPF program type bpfd supports. Edit the sample yaml files to customize any configuration values: TcProgram CRD: go-tc-counter-bytecode.yaml TracepointProgram CRD: go-tracepoint-counter-bytecode.yaml XdpProgram CRD: go-xdp-counter-bytecode.yaml Sample bytecode yaml with XdpProgram CRD: vi examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter-bytecode.yaml apiVersion: bpfd.io/v1alpha1 kind: XdpProgram metadata: labels: app.kubernetes.io/name: xdpprogram name: go-xdp-counter-example spec: sectionname: stats # Select all nodes nodeselector: {} interfaceselector: primarynodeinterface: true priority: 55 bytecode: image: url: quay.io/bpfd-bytecode/go-xdp-counter:latest Note that all the sample yaml files are configured with the bytecode running on all nodes ( nodeselector: {} ). This can be change to run on specific nodes, but the DaemonSet yaml for the userspace program, which is described below, should have an equivalent change. Make any changes to the go-xdp-counter-bytecode.yaml , then repeat for go-tc-counter-bytecode.yaml and go-tracepoint-counter-bytecode.yaml and then apply the updated yamls: kubectl apply -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter-bytecode.yaml xdpprogram.bpfd.io/go-xdp-counter-example created kubectl apply -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter-bytecode.yaml tcprogram.bpfd.io/go-tc-counter-example created kubectl apply -f examples/go-tracepoint-counter/kubernetes-deployment/go-tracepoint-counter-bytecode.yaml tracepointprogram.bpfd.io/go-tracepoint-counter-example created Following the diagram for XDP example (Blue numbers): The user creates a XdpProgram object with the parameters associated with the eBPF bytecode, like interface, priority and BFP bytecode image. The name of the XdpProgram object in this example is go-xdp-counter-example . bpfd-agent , running on each node, is watching for all changes to XdpProgram objects. When it sees a XdpProgram object created or modified, it makes sure a BpfProgram object for that node exists. The name of the BpfProgram object is the XdpProgram object name with the node name appended. bpfd-agent then determines if it should be running on the given node, loads or unloads as needed by making gRPC calls the bpfd . bpfd behaves the same as described in the running locally example. bpfd-agent finally updates the status of the BpfProgram object. bpfd-operator watches all BpfProgram objects, and updates the status of the XdpProgram object indicating if the eBPF program has been applied to all the desired nodes or not. To retrieve information on the XdpProgram objects: kubectl get xdpprograms NAME PRIORITY DIRECTION go-xdp-counter-example 55 kubectl get xdpprograms go-xdp-counter-example -o yaml apiVersion: bpfd.io/v1alpha1 kind: XdpProgram metadata: creationTimestamp: \"2023-05-04T15:41:45Z\" finalizers: - bpfd.io.operator/finalizer generation: 1 labels: app.kubernetes.io/name: xdpprogram name: go-xdp-counter-example resourceVersion: \"1786\" uid: 19a64cf8-3909-4a61-a5c0-5a3ddb95769c spec: bytecode: image: imagepullpolicy: IfNotPresent url: quay.io/bpfd-bytecode/go-xdp-counter:latest interfaceselector: primarynodeinterface: true nodeselector: {} priority: 55 proceedon: - pass - dispatcher_return sectionname: stats status: conditions: - lastTransitionTime: \"2023-05-04T15:41:45Z\" message: Waiting for BpfProgramConfig Object to be reconciled to all nodes reason: ProgramsNotYetLoaded status: \"True\" type: NotYetLoaded - lastTransitionTime: \"2023-05-04T15:41:45Z\" message: bpfProgramReconciliation Succeeded on all nodes reason: ReconcileSuccess status: \"True\" type: ReconcileSuccess To retrieve information on the BpfProgram objects: kubectl get bpfprograms NAME AGE go-tc-counter-example-bpfd-deployment-control-plane 8m52s go-tc-counter-example-bpfd-deployment-worker 8m53s go-tc-counter-example-bpfd-deployment-worker2 8m53s go-tracepoint-counter-example-bpfd-deployment-control-plane 8m52s go-tracepoint-counter-example-bpfd-deployment-worker 8m53s go-tracepoint-counter-example-bpfd-deployment-worker2 8m53s go-xdp-counter-example-bpfd-deployment-control-plane 8m54s go-xdp-counter-example-bpfd-deployment-worker 8m54s go-xdp-counter-example-bpfd-deployment-worker2 8m54s kubectl get bpfprograms go-xdp-counter-example-bpfd-deployment-worker -o yaml apiVersion: bpfd.io/v1alpha1 kind: BpfProgram metadata: creationTimestamp: \"2023-05-04T15:41:45Z\" finalizers: - bpfd.io.xdpprogramcontroller-finalizer generation: 2 labels: ownedByProgram: go-xdp-counter-example name: go-xdp-counter-example-bpfd-deployment-worker ownerReferences: - apiVersion: bpfd.io/v1alpha1 blockOwnerDeletion: true controller: true kind: XdpProgram name: go-xdp-counter-example uid: 19a64cf8-3909-4a61-a5c0-5a3ddb95769c resourceVersion: \"1869\" uid: 93a0f736-4a7a-48c2-b6ff-bc715b3580d6 spec: node: bpfd-deployment-worker programs: ff121084-1211-4fa4-bb16-ddd18e3c63d5: xdp_stats_map: /run/bpfd/fs/maps/ff121084-1211-4fa4-bb16-ddd18e3c63d5/xdp_stats_map type: xdp status: conditions: - lastTransitionTime: \"2023-05-04T15:41:46Z\" message: Successfully loaded bpfProgram reason: bpfdLoaded status: \"True\" type: Loaded","title":"Loading eBPF Bytecode On Kubernetes"},{"location":"getting-started/example-bpf-k8s/#loading-userspace-container-on-kubernetes","text":"","title":"Loading Userspace Container On Kubernetes"},{"location":"getting-started/example-bpf-k8s/#loading-a-userspace-container-image","text":"The userspace programs have been pre-built and can be found here: quay.io/bpfd-userspace/go-tc-counter:latest quay.io/bpfd-userspace/go-tracepoint-counter:latest quay.io/bpfd-userspace/go-xdp-counter:latest The example yaml files below are loading from these image. go-tc-counter.yaml go-tracepoint-counter.yaml go-xdp-counter.yaml The userspace program in a Kubernetes Deployment no longer interacts directly with bpfd . Instead, the userspace program running on each node reads the BpfProgram to determine the map location. For example, the output above shows the maps as: kubectl get bpfprograms go-xdp-counter-example-bpfd-deployment-worker -o yaml : spec: node: bpfd-deployment-worker programs: ff121084-1211-4fa4-bb16-ddd18e3c63d5: xdp_stats_map: /run/bpfd/fs/maps/ff121084-1211-4fa4-bb16-ddd18e3c63d5/xdp_stats_map type: xdp : To interact with the KubeApiServer, RBAC must be setup properly to access the BpfProgram object. The bpfd-operator defined the yaml for several ClusterRoles that can be used to access the different bpfd related CRD objects with different access rights. The example userspace containers will use the bpfprogram-viewer-role , which allows Read-Only access to the BpfProgram object. This ClusterRole is created automatically by the bpfd-operator . The remaining objects (NameSpace, ServiceAccount, ClusterRoleBinding and examples DaemonSet) also need to be created. cd bpfd/ kubectl create -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter.yaml kubectl create -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter.yaml kubectl create -f examples/go-tracepoint-counter/kubernetes-deployment/go-tracepoint-counter.yaml Following the diagram for the XDP example (Green numbers): The userspace program queries the KubeApiServer for a specific BpfProgram object. The userspace program pulls the file location of the shared map out of the BpfProgram object and uses the file to periodically read the counter values. To see if the userspace programs are working, view the logs: kubectl get pods -A NAMESPACE NAME READY STATUS RESTARTS AGE : go-tc-counter go-tc-counter-ds-2dfn8 1/1 Running 0 16m go-tc-counter go-tc-counter-ds-mn82s 1/1 Running 0 16m go-tc-counter go-tc-counter-ds-qbf9w 1/1 Running 0 16m go-tracepoint-counter go-tracepoint-counter-ds-686g5 1/1 Running 0 16m go-tracepoint-counter go-tracepoint-counter-ds-tzj2r 1/1 Running 0 16m go-tracepoint-counter go-tracepoint-counter-ds-zfz6k 1/1 Running 0 16m go-xdp-counter go-xdp-counter-ds-c626t 1/1 Running 0 16m go-xdp-counter go-xdp-counter-ds-kskgh 1/1 Running 0 16m go-xdp-counter go-xdp-counter-ds-xx6dp 1/1 Running 0 16m : kubectl logs -n go-xdp-counter go-xdp-counter-ds-5q4hz 2023/01/08 08:47:55 908748 packets received 2023/01/08 08:47:55 631463477 bytes received 2023/01/08 08:47:58 908757 packets received 2023/01/08 08:47:58 631466099 bytes received 2023/01/08 08:48:01 908778 packets received 2023/01/08 08:48:01 631472201 bytes received 2023/01/08 08:48:04 908791 packets received 2023/01/08 08:48:04 631480013 bytes received : To cleanup: kubectl delete -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter.yaml kubectl delete -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter-bytecode.yaml kubectl delete -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter.yaml kubectl delete -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter-bytecode.yaml kubectl delete -f examples/go-tracepoint-counter/kubernetes-deployment/go-tracepoint-counter.yaml kubectl delete -f examples/go-tracepoint-counter/kubernetes-deployment/go-tracepoint-counter-bytecode.yaml There are two scripts that will automate the steps described above: cd bpfd ./scripts/cr-k8s-examples.sh xdpprogram.bpfd.io/go-xdp-counter-example created namespace/go-xdp-counter created serviceaccount/bpfd-app-go-xdp-counter created clusterrolebinding.rbac.authorization.k8s.io/privileged-scc created clusterrolebinding.rbac.authorization.k8s.io/bpfd-app-rolebinding-go-xdp-counter created daemonset.apps/go-xdp-counter-ds created tcprogram.bpfd.io/go-tc-counter-example created namespace/go-tc-counter created serviceaccount/bpfd-app-go-tc-counter created clusterrolebinding.rbac.authorization.k8s.io/bpfd-app-rolebinding-go-tc-counter created daemonset.apps/go-tc-counter-ds created tracepointprogram.bpfd.io/go-tracepoint-counter-example created namespace/go-tracepoint-counter created serviceaccount/bpfd-app-go-tracepoint-counter created clusterrolebinding.rbac.authorization.k8s.io/bpfd-app-rolebinding-go-tracepoint-counter created daemonset.apps/go-tracepoint-counter-ds created # Test Away ... ./scripts/del-k8s-examples.sh serviceaccount \"bpfd-app-go-xdp-counter\" deleted clusterrolebinding.rbac.authorization.k8s.io \"privileged-scc\" deleted clusterrolebinding.rbac.authorization.k8s.io \"bpfd-app-rolebinding-go-xdp-counter\" deleted daemonset.apps \"go-xdp-counter-ds\" deleted xdpprogram.bpfd.io \"go-xdp-counter-example\" deleted namespace \"go-tc-counter\" deleted serviceaccount \"bpfd-app-go-tc-counter\" deleted clusterrolebinding.rbac.authorization.k8s.io \"bpfd-app-rolebinding-go-tc-counter\" deleted daemonset.apps \"go-tc-counter-ds\" deleted tcprogram.bpfd.io \"go-tc-counter-example\" deleted namespace \"go-tracepoint-counter\" deleted serviceaccount \"bpfd-app-go-tracepoint-counter\" deleted clusterrolebinding.rbac.authorization.k8s.io \"bpfd-app-rolebinding-go-tracepoint-counter\" deleted daemonset.apps \"go-tracepoint-counter-ds\" deleted tracepointprogram.bpfd.io \"go-tracepoint-counter-example\" deleted","title":"Loading A Userspace Container Image"},{"location":"getting-started/example-bpf-k8s/#building-a-userspace-container-image","text":"To build the userspace examples in a container instead of using the pre-built ones, from the bpfd code source directory, run the following build commands: cd bpfd/ docker build -f examples/go-xdp-counter/container-deployment/Containerfile.go-xdp-counter . -t quay.io/$USER/go-xdp-counter:latest docker build -f examples/go-tc-counter/container-deployment/Containerfile.go-tc-counter . -t quay.io/$USER/go-tc-counter:latest docker build -f examples/go-tracepoint-counter/container-deployment/Containerfile.go-tracepoint-counter . -t quay.io/$USER/go-tracepoint-counter:latest Then push images to a remote repository: docker login quay.io docker push quay.io/$USER/go-xdp-counter:latest docker push quay.io/$USER/go-tc-counter:latest docker push quay.io/$USER/go-tracepoint-counter:latest Update the yaml to use the private images.","title":"Building A Userspace Container Image"},{"location":"getting-started/example-bpf-local/","text":"Deploying Example eBPF Programs On Local Host This section describes running bpfd and the example eBPF programs on a local host. When running bpfd, it can be run as a process or run as a systemd service. Examples run the same, independent of how bpfd is deployed, other than requiring sudo or not. NOTE: When running bpfd as a systemd service, bpfd can only access files owned by the bpfd user, which is created by the install script ( ./script/setup.sh install ). In this case, the install script also copies the examples eBPF bytecode from the examples directory to a directory owned by bpfd ( /run/bpfd/examples/ ). When bpfd is run as a privileged process, the bytecode can be loaded from the examples directory. The example code looks in both locations ( /run/bpfd/examples/ first), so if the bytecode is recompiled and bpfd is running as a systemd service, run ./script/setup.sh examples to update the copied version. Building To build directly on a system, make sure all the prerequisites are met, then build. Prerequisites This assumes bpfd is already installed and running on the system. If not, see Setup and Building bpfd . All requirements defined by the cilium/ebpf package libbpf development package to get the required eBPF c headers Fedora: sudo dnf install libbpf-devel Ubuntu: sudo apt-get install libbpf-dev Cilium's bpf2go binary go install github.com/cilium/ebpf/cmd/bpf2go@master Building Locally To build the C based eBPF counter bytecode, run: cd bpfd/examples/go-xdp-counter/ go generate To build the Userspace GO Client run: cd bpfd/examples/go-xdp-counter/ go build Repeat for TC and Tracepoint if desired: cd bpfd/examples/go-tc-counter/ go generate go build cd bpfd/examples/go-tracepoint-counter/ go generate go build Running On Host The most basic way to deploy this example is running directly on a host system. First, start or ensure bpfd is up and running. Tutorial will guide you through deploying bpfd . In all the examples of running on a host system, a bpfd-client certificate is used that is generated by bpfd to encrypt the application's connection to bpfd . The diagram below shows go-xdp-counter example, but the go-tc-counter and go-tracepoint-counter examples operate exactly the same way. Following the diagram (Purple numbers): When go-xdp-counter userspace is started, it will send a gRPC request over mTLS to bpfd requesting bpfd to load the go-xdp-counter eBPF bytecode located on disk at bpfd/examples/go-xdp-counter/bpf_bpfel.o at a priority of 50 and on interface ens3 . These values are configurable as we will see later, but for now we will use the defaults (except interface, which is required to be entered). bpfd will load it's dispatcher eBPF program, which links to the go-xdp-counter eBPF program and return a UUID referencing the running program. bpfctl list can be used to show that the eBPF program was loaded. Once the go-xdp-counter eBPF bytecode is loaded, the eBPF program will write packet counts and byte counts to a shared map. go-xdp-counter userspace program periodically reads counters from the shared map and logs the value. Running Privileged The most basic example, just use sudo to start the go-xdp-counter program. Determine the host interface to attach the eBPF program to and then start the go program with: cd bpfd/examples/go-xdp-counter/ sudo ./go-xdp-counter -iface <INTERNET INTERFACE NAME> or ( NOTE: TC programs also require a direction, ingress or egress) cd bpfd/examples/go-tc-counter/ sudo ./go-tc-counter -direction ingress -iface <INTERNET INTERFACE NAME> or cd bpfd/examples/go-tracepoint-counter/ sudo ./go-tracepoint-counter The output should show the count and total bytes of packets as they pass through the interface as shown below: sudo ./go-xdp-counter -iface ens3 2022/12/02 15:59:34 Unable to read /etc/bpfd/bpfd.toml, using default configuration values. 2022/12/02 15:59:34 Unable to find primary bytecode file: /run/bpfd/examples/go-xdp-counter/bpf_bpfel.o 2022/12/02 15:59:34 Using Input: Interface=ens3 Priority=50 Source=/home/$USER/src/bpfd/examples/go-xdp-counter/bpf_bpfel.o 2022/12/02 15:59:35 Program registered with b6b2107c-f1a3-48ac-a145-1073c0979ba4 id 2022/12/02 15:59:38 0 packets received 2022/12/02 15:59:38 0 bytes received 2022/12/02 15:59:41 4 packets received 2022/12/02 15:59:41 580 bytes received : Use bpfctl to show the go-xdp-counter eBPF bytecode was loaded. bpfctl list UUID Type Name Location Metadata b6b2107c-f1a3-48ac-a145-1073c0979ba4 xdp stats file: { path: /home/$USER/src/bpfd/examples/go-xdp-counter/bpf_bpfel.o } { priority: 50, iface: ens3, position: 0, proceed_on: pass, dispatcher_return } Finally, press <CTRL>+c when finished with go-xdp-counter . : 2022/12/02 16:00:56 64 packets received 2022/12/02 16:00:56 9280 bytes received 2022/12/02 16:00:59 64 packets received 2022/12/02 16:00:59 9280 bytes received ^C2022/12/02 16:01:00 Exiting... 2022/12/02 16:01:00 Unloading Program: b6b2107c-f1a3-48ac-a145-1073c0979ba4 Running Unprivileged To run the examples unprivileged (without sudo ), the following three steps must be performed. Step 1: Create bpfd User Group The Tutorial guide describes the different modes bpfd can be run in. Specifically, the Systemd Service section explains how to start bpfd and create the bpfd Users and bpfd User Group. bpfd must be started as a Systemd Service and the examples must be run from a User that is a member of the bpfd User Group. sudo usermod -a -G bpfd $USER exit <LOGIN> If the user running the userspace program is not a member of the bpfd user group, then the userspace program cannot access the map files shared between the BFP program and the userspace program. If the above step is skipped, then the userspace program must be run with sudo or the program must be granted CAP_DAC_OVERRIDE capabilities ( sudo /sbin/setcap cap_dac_override=ep ./go-xdp-counter ). Step 2: Grant CAP_BPF Linux Capability NOTE: Only for kernel versions prior to kernel 5.19 The examples use a map to share data between the userspace side of the program and the eBPF portion. Accessing this map requires access to the CAP_BPF capability for kernel versions prior to kernel 5.19 . Run the following command to grant go-xdp-counter access to the CAP_BPF capability: cd bpfd/examples/go-xdp-counter/ sudo /sbin/setcap cap_bpf=ep ./go-xdp-counter and cd bpfd/examples/go-tc-counter/ sudo /sbin/setcap cap_bpf=ep ./go-tc-counter and cd bpfd/examples/go-tracepoint-counter/ sudo /sbin/setcap cap_bpf=ep ./go-tracepoint-counter Reminder: The capability must be re-granted each time the examples are rebuilt. Step 3: Start go-xdp-counter without sudo Start go-xdp-counter without sudo : ./go-xdp-counter -iface ens3 2022/12/02 15:59:34 Unable to read /etc/bpfd/bpfd.toml, using default configuration values. 2022/12/02 15:59:34 Using Input: Interface=ens3 Priority=50 Source=/run/bpfd/examples/go-xdp-counter/bpf_bpfel.o 2022/12/02 15:59:35 Program registered with b6b2107c-f1a3-48ac-a145-1073c0979ba4 id 2022/12/02 15:59:38 0 packets received 2022/12/02 15:59:38 0 bytes received 2022/12/02 15:59:41 4 packets received 2022/12/02 15:59:41 580 bytes received : 2022/12/02 16:00:59 64 packets received 2022/12/02 16:00:59 9280 bytes received ^C2022/12/02 16:01:00 Exiting... 2022/12/02 16:01:00 Unloading Program: b6b2107c-f1a3-48ac-a145-1073c0979ba4 Passing eBPF Bytecode In A Container Image bpfd can load eBPF bytecode from a container image built following the spec described in eBPF Bytecode Image Specifications . Pre-built eBPF container images for the examples can be loaded from: quay.io/bpfd-bytecode/go-xdp-counter:latest quay.io/bpfd-bytecode/go-tc-counter:latest quay.io/bpfd-bytecode/go-tracepoint-counter:latest To use the container image, pass the URL to the userspace program: ./go-xdp-counter -iface ens3 -image quay.io/bpfd-bytecode/go-xdp-counter:latest 2022/12/02 16:28:32 Unable to read /etc/bpfd/bpfd.toml, using default configuration values. 2022/12/02 16:28:32 Using Input: Interface=ens3 Priority=50 Source=quay.io/bpfd-bytecode/go-xdp-counter:latest 2022/12/02 16:28:34 Program registered with 8d89a6b6-bce2-4d3f-9cee-9cb0c689a90e id 2022/12/02 16:28:37 4 packets received 2022/12/02 16:28:37 580 bytes received 2022/12/02 16:28:40 4 packets received 2022/12/02 16:28:40 580 bytes received ^C2022/12/02 16:28:42 Exiting... 2022/12/02 16:28:42 Unloading Program: 8d89a6b6-bce2-4d3f-9cee-9cb0c689a90e Building eBPF Bytecode Container Image eBPF Bytecode Image Specifications provides detailed instructions on building and shipping bytecode in a container image. To build go-xdp-counter and go-tc-counter eBPF bytecode container image, first make sure the bytecode has been built (i.e. bpf_bpfel.o has been built - see Building ), then run the build commands below: cd bpfd/examples/go-xdp-counter/ go generate docker build \\ --build-arg PROGRAM_NAME=go-xdp-counter \\ --build-arg SECTION_NAME=stats \\ --build-arg PROGRAM_TYPE=xdp \\ --build-arg BYTECODE_FILENAME=bpf_bpfel.o \\ --build-arg KERNEL_COMPILE_VER=$(uname -r) \\ -f ../../packaging/container-deployment/Containerfile.bytecode . -t quay.io/$USER/go-xdp-counter-bytecode:latest and cd bpfd/examples/go-tc-counter/ go generate docker build \\ --build-arg PROGRAM_NAME=go-tc-counter \\ --build-arg SECTION_NAME=stats \\ --build-arg PROGRAM_TYPE=tc \\ --build-arg BYTECODE_FILENAME=bpf_bpfel.o \\ --build-arg KERNEL_COMPILE_VER=$(uname -r) \\ -f ../../packaging/container-deployment/Containerfile.bytecode . -t quay.io/$USER/go-tc-counter-bytecode:latest and cd bpfd/examples/go-tracepoint-counter/ go generate docker build \\ --build-arg PROGRAM_NAME=go-tracepoint-counter \\ --build-arg SECTION_NAME=tracepoint_kill_recorder \\ --build-arg PROGRAM_TYPE=tracepoint \\ --build-arg BYTECODE_FILENAME=bpf_bpfel.o \\ --build-arg KERNEL_COMPILE_VER=$(uname -r) \\ -f ../../packaging/container-deployment/Containerfile.bytecode . -t quay.io/$USER/go-tracepoint-counter-bytecode:latest bpfd currently does not provide a method for pre-loading bytecode images (see issue #429 ), so push the bytecode image to a remote repository. For example: docker login quay.io docker push quay.io/$USER/go-xdp-counter-bytecode:latest docker push quay.io/$USER/go-tc-counter-bytecode:latest Then run with the privately built bytecode container image: ./go-tc-counter -iface ens3 -direction ingress -location image://quay.io/$USER/go-tc-counter-bytecode:latest 2022/12/02 16:38:44 Unable to read /etc/bpfd/bpfd.toml, using default configuration values. 2022/12/02 16:38:44 Using Input: Interface=ens3 Priority=50 Source=quay.io/$USER/go-tc-counter-bytecode:latest 2022/12/02 16:38:45 Program registered with 0d313a4a-a17c-4c70-81ba-3ecc494b900e id 2022/12/02 16:38:48 4 packets received 2022/12/02 16:38:48 580 bytes received 2022/12/02 16:38:51 4 packets received 2022/12/02 16:38:51 580 bytes received ^C2022/12/02 16:38:51 Exiting... 2022/12/02 16:38:51 Unloading Program: 0d313a4a-a17c-4c70-81ba-3ecc494b900e Preloading eBPF Bytecode Another way to load the eBPF bytecode is to pre-load the eBPF bytecode and pass the associated bpfd UUID to the userspace program. This is similar to how eBPF programs will be loaded in Kubernetes, except kubectl commands will be used to create Kubernetes CRD objects instead of using bpfctl , but that is covered in the next section. The userspace programs will skip the loading portion and use the UUID to find the shared map and continue from there. Referring back to the diagram above, the load and unload are being done by bpfctl and not go-xdp-counter userspace program. First, use bpfctl to load the go-xdp-counter eBPF bytecode: bpfctl load-from-image --image-url quay.io/bpfd-bytecode/go-xdp-counter:latest xdp --iface ens3 --priority 50 d541af30-69be-44cf-9397-407ee512547a Then run the go-xdp-counter userspace program, passing in the UUID: ./go-xdp-counter -iface ens3 -uuid d541af30-69be-44cf-9397-407ee512547a 2022/12/02 17:01:38 Using Input: Interface=ens3 Source=d541af30-69be-44cf-9397-407ee512547a 2022/12/02 17:01:41 180 packets received 2022/12/02 17:01:41 26100 bytes received 2022/12/02 17:01:44 184 packets received 2022/12/02 17:01:44 26680 bytes received ^C2022/12/02 17:01:46 Exiting... Then use bpfctl to unload the eBPF bytecode: bpfctl unload d541af30-69be-44cf-9397-407ee512547a","title":"Deploying Example eBPF Programs On Local Host"},{"location":"getting-started/example-bpf-local/#deploying-example-ebpf-programs-on-local-host","text":"This section describes running bpfd and the example eBPF programs on a local host. When running bpfd, it can be run as a process or run as a systemd service. Examples run the same, independent of how bpfd is deployed, other than requiring sudo or not. NOTE: When running bpfd as a systemd service, bpfd can only access files owned by the bpfd user, which is created by the install script ( ./script/setup.sh install ). In this case, the install script also copies the examples eBPF bytecode from the examples directory to a directory owned by bpfd ( /run/bpfd/examples/ ). When bpfd is run as a privileged process, the bytecode can be loaded from the examples directory. The example code looks in both locations ( /run/bpfd/examples/ first), so if the bytecode is recompiled and bpfd is running as a systemd service, run ./script/setup.sh examples to update the copied version.","title":"Deploying Example eBPF Programs On Local Host"},{"location":"getting-started/example-bpf-local/#building","text":"To build directly on a system, make sure all the prerequisites are met, then build.","title":"Building"},{"location":"getting-started/example-bpf-local/#prerequisites","text":"This assumes bpfd is already installed and running on the system. If not, see Setup and Building bpfd . All requirements defined by the cilium/ebpf package libbpf development package to get the required eBPF c headers Fedora: sudo dnf install libbpf-devel Ubuntu: sudo apt-get install libbpf-dev Cilium's bpf2go binary go install github.com/cilium/ebpf/cmd/bpf2go@master","title":"Prerequisites"},{"location":"getting-started/example-bpf-local/#building-locally","text":"To build the C based eBPF counter bytecode, run: cd bpfd/examples/go-xdp-counter/ go generate To build the Userspace GO Client run: cd bpfd/examples/go-xdp-counter/ go build Repeat for TC and Tracepoint if desired: cd bpfd/examples/go-tc-counter/ go generate go build cd bpfd/examples/go-tracepoint-counter/ go generate go build","title":"Building Locally"},{"location":"getting-started/example-bpf-local/#running-on-host","text":"The most basic way to deploy this example is running directly on a host system. First, start or ensure bpfd is up and running. Tutorial will guide you through deploying bpfd . In all the examples of running on a host system, a bpfd-client certificate is used that is generated by bpfd to encrypt the application's connection to bpfd . The diagram below shows go-xdp-counter example, but the go-tc-counter and go-tracepoint-counter examples operate exactly the same way. Following the diagram (Purple numbers): When go-xdp-counter userspace is started, it will send a gRPC request over mTLS to bpfd requesting bpfd to load the go-xdp-counter eBPF bytecode located on disk at bpfd/examples/go-xdp-counter/bpf_bpfel.o at a priority of 50 and on interface ens3 . These values are configurable as we will see later, but for now we will use the defaults (except interface, which is required to be entered). bpfd will load it's dispatcher eBPF program, which links to the go-xdp-counter eBPF program and return a UUID referencing the running program. bpfctl list can be used to show that the eBPF program was loaded. Once the go-xdp-counter eBPF bytecode is loaded, the eBPF program will write packet counts and byte counts to a shared map. go-xdp-counter userspace program periodically reads counters from the shared map and logs the value.","title":"Running On Host"},{"location":"getting-started/example-bpf-local/#running-privileged","text":"The most basic example, just use sudo to start the go-xdp-counter program. Determine the host interface to attach the eBPF program to and then start the go program with: cd bpfd/examples/go-xdp-counter/ sudo ./go-xdp-counter -iface <INTERNET INTERFACE NAME> or ( NOTE: TC programs also require a direction, ingress or egress) cd bpfd/examples/go-tc-counter/ sudo ./go-tc-counter -direction ingress -iface <INTERNET INTERFACE NAME> or cd bpfd/examples/go-tracepoint-counter/ sudo ./go-tracepoint-counter The output should show the count and total bytes of packets as they pass through the interface as shown below: sudo ./go-xdp-counter -iface ens3 2022/12/02 15:59:34 Unable to read /etc/bpfd/bpfd.toml, using default configuration values. 2022/12/02 15:59:34 Unable to find primary bytecode file: /run/bpfd/examples/go-xdp-counter/bpf_bpfel.o 2022/12/02 15:59:34 Using Input: Interface=ens3 Priority=50 Source=/home/$USER/src/bpfd/examples/go-xdp-counter/bpf_bpfel.o 2022/12/02 15:59:35 Program registered with b6b2107c-f1a3-48ac-a145-1073c0979ba4 id 2022/12/02 15:59:38 0 packets received 2022/12/02 15:59:38 0 bytes received 2022/12/02 15:59:41 4 packets received 2022/12/02 15:59:41 580 bytes received : Use bpfctl to show the go-xdp-counter eBPF bytecode was loaded. bpfctl list UUID Type Name Location Metadata b6b2107c-f1a3-48ac-a145-1073c0979ba4 xdp stats file: { path: /home/$USER/src/bpfd/examples/go-xdp-counter/bpf_bpfel.o } { priority: 50, iface: ens3, position: 0, proceed_on: pass, dispatcher_return } Finally, press <CTRL>+c when finished with go-xdp-counter . : 2022/12/02 16:00:56 64 packets received 2022/12/02 16:00:56 9280 bytes received 2022/12/02 16:00:59 64 packets received 2022/12/02 16:00:59 9280 bytes received ^C2022/12/02 16:01:00 Exiting... 2022/12/02 16:01:00 Unloading Program: b6b2107c-f1a3-48ac-a145-1073c0979ba4","title":"Running Privileged"},{"location":"getting-started/example-bpf-local/#running-unprivileged","text":"To run the examples unprivileged (without sudo ), the following three steps must be performed.","title":"Running Unprivileged"},{"location":"getting-started/example-bpf-local/#step-1-create-bpfd-user-group","text":"The Tutorial guide describes the different modes bpfd can be run in. Specifically, the Systemd Service section explains how to start bpfd and create the bpfd Users and bpfd User Group. bpfd must be started as a Systemd Service and the examples must be run from a User that is a member of the bpfd User Group. sudo usermod -a -G bpfd $USER exit <LOGIN> If the user running the userspace program is not a member of the bpfd user group, then the userspace program cannot access the map files shared between the BFP program and the userspace program. If the above step is skipped, then the userspace program must be run with sudo or the program must be granted CAP_DAC_OVERRIDE capabilities ( sudo /sbin/setcap cap_dac_override=ep ./go-xdp-counter ).","title":"Step 1: Create bpfd User Group"},{"location":"getting-started/example-bpf-local/#step-2-grant-cap_bpf-linux-capability","text":"NOTE: Only for kernel versions prior to kernel 5.19 The examples use a map to share data between the userspace side of the program and the eBPF portion. Accessing this map requires access to the CAP_BPF capability for kernel versions prior to kernel 5.19 . Run the following command to grant go-xdp-counter access to the CAP_BPF capability: cd bpfd/examples/go-xdp-counter/ sudo /sbin/setcap cap_bpf=ep ./go-xdp-counter and cd bpfd/examples/go-tc-counter/ sudo /sbin/setcap cap_bpf=ep ./go-tc-counter and cd bpfd/examples/go-tracepoint-counter/ sudo /sbin/setcap cap_bpf=ep ./go-tracepoint-counter Reminder: The capability must be re-granted each time the examples are rebuilt.","title":"Step 2: Grant CAP_BPF Linux Capability"},{"location":"getting-started/example-bpf-local/#step-3-start-go-xdp-counter-without-sudo","text":"Start go-xdp-counter without sudo : ./go-xdp-counter -iface ens3 2022/12/02 15:59:34 Unable to read /etc/bpfd/bpfd.toml, using default configuration values. 2022/12/02 15:59:34 Using Input: Interface=ens3 Priority=50 Source=/run/bpfd/examples/go-xdp-counter/bpf_bpfel.o 2022/12/02 15:59:35 Program registered with b6b2107c-f1a3-48ac-a145-1073c0979ba4 id 2022/12/02 15:59:38 0 packets received 2022/12/02 15:59:38 0 bytes received 2022/12/02 15:59:41 4 packets received 2022/12/02 15:59:41 580 bytes received : 2022/12/02 16:00:59 64 packets received 2022/12/02 16:00:59 9280 bytes received ^C2022/12/02 16:01:00 Exiting... 2022/12/02 16:01:00 Unloading Program: b6b2107c-f1a3-48ac-a145-1073c0979ba4","title":"Step 3: Start go-xdp-counter without sudo"},{"location":"getting-started/example-bpf-local/#passing-ebpf-bytecode-in-a-container-image","text":"bpfd can load eBPF bytecode from a container image built following the spec described in eBPF Bytecode Image Specifications . Pre-built eBPF container images for the examples can be loaded from: quay.io/bpfd-bytecode/go-xdp-counter:latest quay.io/bpfd-bytecode/go-tc-counter:latest quay.io/bpfd-bytecode/go-tracepoint-counter:latest To use the container image, pass the URL to the userspace program: ./go-xdp-counter -iface ens3 -image quay.io/bpfd-bytecode/go-xdp-counter:latest 2022/12/02 16:28:32 Unable to read /etc/bpfd/bpfd.toml, using default configuration values. 2022/12/02 16:28:32 Using Input: Interface=ens3 Priority=50 Source=quay.io/bpfd-bytecode/go-xdp-counter:latest 2022/12/02 16:28:34 Program registered with 8d89a6b6-bce2-4d3f-9cee-9cb0c689a90e id 2022/12/02 16:28:37 4 packets received 2022/12/02 16:28:37 580 bytes received 2022/12/02 16:28:40 4 packets received 2022/12/02 16:28:40 580 bytes received ^C2022/12/02 16:28:42 Exiting... 2022/12/02 16:28:42 Unloading Program: 8d89a6b6-bce2-4d3f-9cee-9cb0c689a90e","title":"Passing eBPF Bytecode In A Container Image"},{"location":"getting-started/example-bpf-local/#building-ebpf-bytecode-container-image","text":"eBPF Bytecode Image Specifications provides detailed instructions on building and shipping bytecode in a container image. To build go-xdp-counter and go-tc-counter eBPF bytecode container image, first make sure the bytecode has been built (i.e. bpf_bpfel.o has been built - see Building ), then run the build commands below: cd bpfd/examples/go-xdp-counter/ go generate docker build \\ --build-arg PROGRAM_NAME=go-xdp-counter \\ --build-arg SECTION_NAME=stats \\ --build-arg PROGRAM_TYPE=xdp \\ --build-arg BYTECODE_FILENAME=bpf_bpfel.o \\ --build-arg KERNEL_COMPILE_VER=$(uname -r) \\ -f ../../packaging/container-deployment/Containerfile.bytecode . -t quay.io/$USER/go-xdp-counter-bytecode:latest and cd bpfd/examples/go-tc-counter/ go generate docker build \\ --build-arg PROGRAM_NAME=go-tc-counter \\ --build-arg SECTION_NAME=stats \\ --build-arg PROGRAM_TYPE=tc \\ --build-arg BYTECODE_FILENAME=bpf_bpfel.o \\ --build-arg KERNEL_COMPILE_VER=$(uname -r) \\ -f ../../packaging/container-deployment/Containerfile.bytecode . -t quay.io/$USER/go-tc-counter-bytecode:latest and cd bpfd/examples/go-tracepoint-counter/ go generate docker build \\ --build-arg PROGRAM_NAME=go-tracepoint-counter \\ --build-arg SECTION_NAME=tracepoint_kill_recorder \\ --build-arg PROGRAM_TYPE=tracepoint \\ --build-arg BYTECODE_FILENAME=bpf_bpfel.o \\ --build-arg KERNEL_COMPILE_VER=$(uname -r) \\ -f ../../packaging/container-deployment/Containerfile.bytecode . -t quay.io/$USER/go-tracepoint-counter-bytecode:latest bpfd currently does not provide a method for pre-loading bytecode images (see issue #429 ), so push the bytecode image to a remote repository. For example: docker login quay.io docker push quay.io/$USER/go-xdp-counter-bytecode:latest docker push quay.io/$USER/go-tc-counter-bytecode:latest Then run with the privately built bytecode container image: ./go-tc-counter -iface ens3 -direction ingress -location image://quay.io/$USER/go-tc-counter-bytecode:latest 2022/12/02 16:38:44 Unable to read /etc/bpfd/bpfd.toml, using default configuration values. 2022/12/02 16:38:44 Using Input: Interface=ens3 Priority=50 Source=quay.io/$USER/go-tc-counter-bytecode:latest 2022/12/02 16:38:45 Program registered with 0d313a4a-a17c-4c70-81ba-3ecc494b900e id 2022/12/02 16:38:48 4 packets received 2022/12/02 16:38:48 580 bytes received 2022/12/02 16:38:51 4 packets received 2022/12/02 16:38:51 580 bytes received ^C2022/12/02 16:38:51 Exiting... 2022/12/02 16:38:51 Unloading Program: 0d313a4a-a17c-4c70-81ba-3ecc494b900e","title":"Building eBPF Bytecode Container Image"},{"location":"getting-started/example-bpf-local/#preloading-ebpf-bytecode","text":"Another way to load the eBPF bytecode is to pre-load the eBPF bytecode and pass the associated bpfd UUID to the userspace program. This is similar to how eBPF programs will be loaded in Kubernetes, except kubectl commands will be used to create Kubernetes CRD objects instead of using bpfctl , but that is covered in the next section. The userspace programs will skip the loading portion and use the UUID to find the shared map and continue from there. Referring back to the diagram above, the load and unload are being done by bpfctl and not go-xdp-counter userspace program. First, use bpfctl to load the go-xdp-counter eBPF bytecode: bpfctl load-from-image --image-url quay.io/bpfd-bytecode/go-xdp-counter:latest xdp --iface ens3 --priority 50 d541af30-69be-44cf-9397-407ee512547a Then run the go-xdp-counter userspace program, passing in the UUID: ./go-xdp-counter -iface ens3 -uuid d541af30-69be-44cf-9397-407ee512547a 2022/12/02 17:01:38 Using Input: Interface=ens3 Source=d541af30-69be-44cf-9397-407ee512547a 2022/12/02 17:01:41 180 packets received 2022/12/02 17:01:41 26100 bytes received 2022/12/02 17:01:44 184 packets received 2022/12/02 17:01:44 26680 bytes received ^C2022/12/02 17:01:46 Exiting... Then use bpfctl to unload the eBPF bytecode: bpfctl unload d541af30-69be-44cf-9397-407ee512547a","title":"Preloading eBPF Bytecode"},{"location":"getting-started/example-bpf/","text":"Example eBPF Programs Example applications that use the bpfd-go bindings can be found in the examples/ directory. Current examples include: examples/go-tc-counter/ examples/go-tracepoint-counter/ examples/go-xdp-counter/ These examples and the associated documentation is intended to provide the basics on how to deploy and manage a eBPF program using bpfd. Each of the examples contain an eBPF Program written in C ( tc_counter.c , tracepoint_counter.c and xdp_counter.c ) that is compiled into eBPF bytecode. Each time the eBPF program is called, it increments the packet and byte counts in a map that is accessible by the userspace portion. Each of the examples also have a userspace portion written in GO. When run locally, the userspace program makes gRPC calls to bpfd requesting bpfd to load the eBPF program at the requested hook point (XDP hook point, TC hook point or Tracepoint). When run in a Kubernetes deployment, the bpfd-agent makes gRPC calls to bpfd requesting bpfd to load the eBPF program based on a Custom Resource Definition (CRD), which is described in more detail in that section. Independent of the deployment, the userspace program then polls the eBPF map every 3 seconds and logs the current counts. The userspace code is leveraging the cilium/ebpf library to manage the maps shared with the eBPF program. The example eBPF programs are very similar in functionality, and only vary where in the Linux networking stack they are inserted. Read more about XDP and TC programs here . There are two ways to deploy these example applications: Run locally on one machine: Deploying Example eBPF Programs On Local Host Deploy to multiple nodes in a Kubernetes cluster: Deploying Example eBPF Programs On Kubernetes Notes Notes regarding this document: Source of images used in the example documentation can be found in bpfd Upstream Images . Request access if required.","title":"Example eBPF Programs"},{"location":"getting-started/example-bpf/#example-ebpf-programs","text":"Example applications that use the bpfd-go bindings can be found in the examples/ directory. Current examples include: examples/go-tc-counter/ examples/go-tracepoint-counter/ examples/go-xdp-counter/ These examples and the associated documentation is intended to provide the basics on how to deploy and manage a eBPF program using bpfd. Each of the examples contain an eBPF Program written in C ( tc_counter.c , tracepoint_counter.c and xdp_counter.c ) that is compiled into eBPF bytecode. Each time the eBPF program is called, it increments the packet and byte counts in a map that is accessible by the userspace portion. Each of the examples also have a userspace portion written in GO. When run locally, the userspace program makes gRPC calls to bpfd requesting bpfd to load the eBPF program at the requested hook point (XDP hook point, TC hook point or Tracepoint). When run in a Kubernetes deployment, the bpfd-agent makes gRPC calls to bpfd requesting bpfd to load the eBPF program based on a Custom Resource Definition (CRD), which is described in more detail in that section. Independent of the deployment, the userspace program then polls the eBPF map every 3 seconds and logs the current counts. The userspace code is leveraging the cilium/ebpf library to manage the maps shared with the eBPF program. The example eBPF programs are very similar in functionality, and only vary where in the Linux networking stack they are inserted. Read more about XDP and TC programs here . There are two ways to deploy these example applications: Run locally on one machine: Deploying Example eBPF Programs On Local Host Deploy to multiple nodes in a Kubernetes cluster: Deploying Example eBPF Programs On Kubernetes","title":"Example eBPF Programs"},{"location":"getting-started/example-bpf/#notes","text":"Notes regarding this document: Source of images used in the example documentation can be found in bpfd Upstream Images . Request access if required.","title":"Notes"},{"location":"getting-started/tutorial/","text":"Tutorial This tutorial will show you how to use bpfd . There are several ways to launch and interact with bpfd and bpfctl : Privileged Mode - Run bpfd as a privileged process straight from build directory. bpfd user is not created so sudo is always required when executing bpfctl commands. See Privileged Mode . Systemd Service - Run bpfd as a systemd service as the bpfd user. See Systemd Service . Privileged Mode Step 1: Build bpfd Perform the following steps to build bpfd . If this is your first time using bpfd, follow the instructions in Setup and Building bpfd to setup the prerequisites for building. cd $HOME/src/bpfd/ cargo xtask build-ebpf --libbpf-dir $HOME/src/libbpf cargo build Step 2: Setup bpfd environment bpfd supports both mTLS for mutual authentication with clients and connecting via a Unix socket. This tutorial will be using bpfctl , which sends gRPC requests to bpfd over a Unix socket. In the Example eBPF Programs , the GO examples use mTLS over TCP to interact with bpfd . If no local certificate authority exists when bpfd is started, bpfd will automatically create the certificate authority in /etc/bpfd/certs/ . For this step, no additional actions need to be taken. Step 3: Start bpfd While learning and experimenting with bpfd , it may be useful to run bpfd in the foreground (which requires a second terminal to run the bpfctl commands below). For more details on how logging is handled in bpfd, see Logging . sudo RUST_LOG=info ./target/debug/bpfd Step 4: Load your first program We will load the simple xdp-pass program, which permits all traffic to the attached interface, vethb2795c7 in this example. The section in the object file that contains the program is \"xdp\". Finally, we will use the priority of 100. Find a deeper dive into bpfctl syntax in bpfctl Guide . sudo ./target/debug/bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 100 92e3e14c-0400-4a20-be2d-f701af21873c bpfctl returns a unique identifier ( 92e3e14c-0400-4a20-be2d-f701af21873c in this example) to the program that was loaded. This may be used to detach the program later. We can check the program was loaded using the following command: sudo ./target/debug/bpfctl list UUID Type Name Location Metadata 92e3e14c-0400-4a20-be2d-f701af21873c xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 100, iface: vethb2795c7, position: 0, proceed_on: pass, dispatcher_return } From the output above you can see the program was loaded to position 0 on our interface and will be executed first. Step 5: Loading more programs We will now load 2 more programs with different priorities to demonstrate how bpfd will ensure they are ordered correctly: sudo ./target/debug/bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 50 1ccc1376-60e8-4dc5-9079-6c32748fa1c4 sudo ./target/debug/bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 200 6af7c28f-6a7f-46ee-bc98-2d92ed261369 Using bpfctl list we can see that the programs are correctly ordered. The lowest priority program is executed first, while the highest is executed last. sudo ./target/debug/bpfctl list UUID Type Name Location Metadata 1ccc1376-60e8-4dc5-9079-6c32748fa1c4 xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 50, iface: vethb2795c7, position: 0, proceed_on: pass, dispatcher_return } 92e3e14c-0400-4a20-be2d-f701af21873c xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 100, iface: vethb2795c7, position: 1, proceed_on: pass, dispatcher_return } 6af7c28f-6a7f-46ee-bc98-2d92ed261369 xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 200, iface: vethb2795c7, position: 2, proceed_on: pass, dispatcher_return } By default, the next program in the chain will only be executed if a given program returns pass (see proceed-on field in the bpfctl list output above). If the next program in the chain should be called even if a different value is returned, then the program can be loaded with those additional return values using the proceed-on parameter (see bpfctl load-from-image xdp --help for list of valid values): sudo ./target/debug/bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 150 --proceed-on \"pass\" --proceed-on \"dispatcher_return\" b2f19b7b-4c71-4338-873e-914bd8fa44ba Which results in (see position 2): sudo ./target/debug/bpfctl list UUID Type Name Location Metadata 1ccc1376-60e8-4dc5-9079-6c32748fa1c4 xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 50, iface: vethb2795c7, position: 0, proceed_on: pass, dispatcher_return } 92e3e14c-0400-4a20-be2d-f701af21873c xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 100, iface: vethb2795c7, position: 1, proceed_on: pass, dispatcher_return } b2f19b7b-4c71-4338-873e-914bd8fa44ba xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 150, iface: vethb2795c7, position: 2, proceed_on: pass, dispatcher_return } 6af7c28f-6a7f-46ee-bc98-2d92ed261369 xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 200, iface: vethb2795c7, position: 3, proceed_on: pass, dispatcher_return } NOTE: The list of programs may not always be sorted in the order of execution. The position indicates the order of execution, low to high. Step 6: Delete a program Let's remove the program at position 1. sudo ./target/debug/bpfctl unload 92e3e14c-0400-4a20-be2d-f701af21873c And we can verify that it has been removed and the other programs re-ordered: sudo ./target/debug/bpfctl list UUID Type Name Location Metadata 1ccc1376-60e8-4dc5-9079-6c32748fa1c4 xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 50, iface: vethb2795c7, position: 0, proceed_on: pass, dispatcher_return } b2f19b7b-4c71-4338-873e-914bd8fa44ba xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 150, iface: vethb2795c7, position: 1, proceed_on: pass, dispatcher_return } 6af7c28f-6a7f-46ee-bc98-2d92ed261369 xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 200, iface: vethb2795c7, position: 2, proceed_on: pass, dispatcher_return } When bpfd is stopped, all remaining programs will be unloaded automatically. Step 7: Clean-up To unwind all the changes, stop bpfd and then run the following script: sudo ./scripts/setup.sh uninstall WARNING: setup.sh uninstall cleans everything up, so /etc/bpfd/programs.d/ and /run/bpfd/bytecode/ are deleted. Save any changes or files that were created if needed. Systemd Service To run bpfd as a systemd service, the binaries will be placed in a well known location ( /usr/sbin/. ) and a service configuration file will be added ( /usr/lib/systemd/system/bpfd.service ). When run as a systemd service, the set of linux capabilities are limited to only the needed set. If permission errors are encountered, see Linux Capabilities for help debugging. Step 1 Same as Step 1 above, build bpfd if needed: cd $HOME/src/bpfd/ cargo xtask build-ebpf --libbpf-dir $HOME/src/libbpf cargo build Step 2: Setup bpfd environment Run the following command to copy the bpfd and bpfctl binaries to /usr/sbin/ and set the user and user group for each, and copy a default bpfd.service file to /usr/lib/systemd/system/ . This option will also start the systemd service bpfd.service by default: sudo ./scripts/setup.sh install Then add usergroup bpfd to the desired user if not already run and logout/login to apply. Programs run by users which are members of the bpfd user group are able to access the mTLS certificates created by bpfd. Therefore, these programs can make bpfd requests without requiring sudo . For userspace programs accessing maps, the maps are owned by the bpfd user and bpfd user group. Programs run by users which are members of the bpfd user group are able to access the maps files without requiring sudo (specifically CAP_DAC_SEARCH or CAP_DAC_OVERIDE). sudo usermod -a -G bpfd $USER exit <LOGIN> NOTE: Prior to kernel 5.19 , all eBPF sys calls required CAP_BPF, which are used to access maps shared between the BFP program and the userspace program. So userspace programs that are accessing maps and running on kernels older than 5.19 will require either sudo or the CAP_BPF capability ( sudo /sbin/setcap cap_bpf=ep ./<USERSPACE-PROGRAM> ). To update the configuration settings associated with running bpfd as a service, edit the service configuration file: sudo vi /usr/lib/systemd/system/bpfd.service sudo systemctl daemon-reload If bpfd or bpfctl is rebuilt, the following command can be run to install the update binaries without tearing down the users and regenerating the certifications. The bpfd service will is automatically restarted. sudo ./scripts/setup.sh reinstall Step 3: Start bpfd To manage bpfd as a systemd service, use systemctl . sudo ./scripts/setup.sh install will start the service, but the service can be manually stopped and started: sudo systemctl stop bpfd.service ... sudo systemctl start bpfd.service Step 4-6 Same as above except sudo can be dropped from all the bpfctl commands and bpfctl is now in $PATH: bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 100 92e3e14c-0400-4a20-be2d-f701af21873c bpfctl list UUID Type Name Location Metadata 92e3e14c-0400-4a20-be2d-f701af21873c xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 100, iface: vethb2795c7, position: 0, proceed_on: pass, dispatcher_return } bpfctl unload 92e3e14c-0400-4a20-be2d-f701af21873c Step 7: Clean-up To unwind all the changes performed while running bpfd as a systemd service, run the following script. This command cleans up everything, including stopping the bpfd service if it is still running. sudo ./scripts/setup.sh uninstall WARNING: setup.sh uninstall cleans everything up, so /etc/bpfd/programs.d/ and /run/bpfd/bytecode/ are deleted. Save any changes or files that were created if needed. Build and Run Local eBPF Programs In the examples above, all the eBPF programs were pulled from pre-built images. This tutorial uses examples from the xdp-tutorial . The pre-built container images can be found here: https://quay.io/organization/bpfd-bytecode To build these examples locally, check out the xdp-tutorial git repository and compile the examples. eBPF Bytecode Image Specifications describes how eBPF bytecode ispackaged in container images. To load these programs locally, use the bpfctl load-from-file command in place of the bpfctl load-from-image command. For example: sudo ./target/debug/bpfctl load-from-file --path /$HOME/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o --section-name \"xdp\" xdp --iface vethb2795c7 --priority 100","title":"Bpfd on Linux Tutorial"},{"location":"getting-started/tutorial/#tutorial","text":"This tutorial will show you how to use bpfd . There are several ways to launch and interact with bpfd and bpfctl : Privileged Mode - Run bpfd as a privileged process straight from build directory. bpfd user is not created so sudo is always required when executing bpfctl commands. See Privileged Mode . Systemd Service - Run bpfd as a systemd service as the bpfd user. See Systemd Service .","title":"Tutorial"},{"location":"getting-started/tutorial/#privileged-mode","text":"","title":"Privileged Mode"},{"location":"getting-started/tutorial/#step-1-build-bpfd","text":"Perform the following steps to build bpfd . If this is your first time using bpfd, follow the instructions in Setup and Building bpfd to setup the prerequisites for building. cd $HOME/src/bpfd/ cargo xtask build-ebpf --libbpf-dir $HOME/src/libbpf cargo build","title":"Step 1: Build bpfd"},{"location":"getting-started/tutorial/#step-2-setup-bpfd-environment","text":"bpfd supports both mTLS for mutual authentication with clients and connecting via a Unix socket. This tutorial will be using bpfctl , which sends gRPC requests to bpfd over a Unix socket. In the Example eBPF Programs , the GO examples use mTLS over TCP to interact with bpfd . If no local certificate authority exists when bpfd is started, bpfd will automatically create the certificate authority in /etc/bpfd/certs/ . For this step, no additional actions need to be taken.","title":"Step 2: Setup bpfd environment"},{"location":"getting-started/tutorial/#step-3-start-bpfd","text":"While learning and experimenting with bpfd , it may be useful to run bpfd in the foreground (which requires a second terminal to run the bpfctl commands below). For more details on how logging is handled in bpfd, see Logging . sudo RUST_LOG=info ./target/debug/bpfd","title":"Step 3: Start bpfd"},{"location":"getting-started/tutorial/#step-4-load-your-first-program","text":"We will load the simple xdp-pass program, which permits all traffic to the attached interface, vethb2795c7 in this example. The section in the object file that contains the program is \"xdp\". Finally, we will use the priority of 100. Find a deeper dive into bpfctl syntax in bpfctl Guide . sudo ./target/debug/bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 100 92e3e14c-0400-4a20-be2d-f701af21873c bpfctl returns a unique identifier ( 92e3e14c-0400-4a20-be2d-f701af21873c in this example) to the program that was loaded. This may be used to detach the program later. We can check the program was loaded using the following command: sudo ./target/debug/bpfctl list UUID Type Name Location Metadata 92e3e14c-0400-4a20-be2d-f701af21873c xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 100, iface: vethb2795c7, position: 0, proceed_on: pass, dispatcher_return } From the output above you can see the program was loaded to position 0 on our interface and will be executed first.","title":"Step 4: Load your first program"},{"location":"getting-started/tutorial/#step-5-loading-more-programs","text":"We will now load 2 more programs with different priorities to demonstrate how bpfd will ensure they are ordered correctly: sudo ./target/debug/bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 50 1ccc1376-60e8-4dc5-9079-6c32748fa1c4 sudo ./target/debug/bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 200 6af7c28f-6a7f-46ee-bc98-2d92ed261369 Using bpfctl list we can see that the programs are correctly ordered. The lowest priority program is executed first, while the highest is executed last. sudo ./target/debug/bpfctl list UUID Type Name Location Metadata 1ccc1376-60e8-4dc5-9079-6c32748fa1c4 xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 50, iface: vethb2795c7, position: 0, proceed_on: pass, dispatcher_return } 92e3e14c-0400-4a20-be2d-f701af21873c xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 100, iface: vethb2795c7, position: 1, proceed_on: pass, dispatcher_return } 6af7c28f-6a7f-46ee-bc98-2d92ed261369 xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 200, iface: vethb2795c7, position: 2, proceed_on: pass, dispatcher_return } By default, the next program in the chain will only be executed if a given program returns pass (see proceed-on field in the bpfctl list output above). If the next program in the chain should be called even if a different value is returned, then the program can be loaded with those additional return values using the proceed-on parameter (see bpfctl load-from-image xdp --help for list of valid values): sudo ./target/debug/bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 150 --proceed-on \"pass\" --proceed-on \"dispatcher_return\" b2f19b7b-4c71-4338-873e-914bd8fa44ba Which results in (see position 2): sudo ./target/debug/bpfctl list UUID Type Name Location Metadata 1ccc1376-60e8-4dc5-9079-6c32748fa1c4 xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 50, iface: vethb2795c7, position: 0, proceed_on: pass, dispatcher_return } 92e3e14c-0400-4a20-be2d-f701af21873c xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 100, iface: vethb2795c7, position: 1, proceed_on: pass, dispatcher_return } b2f19b7b-4c71-4338-873e-914bd8fa44ba xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 150, iface: vethb2795c7, position: 2, proceed_on: pass, dispatcher_return } 6af7c28f-6a7f-46ee-bc98-2d92ed261369 xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 200, iface: vethb2795c7, position: 3, proceed_on: pass, dispatcher_return } NOTE: The list of programs may not always be sorted in the order of execution. The position indicates the order of execution, low to high.","title":"Step 5: Loading more programs"},{"location":"getting-started/tutorial/#step-6-delete-a-program","text":"Let's remove the program at position 1. sudo ./target/debug/bpfctl unload 92e3e14c-0400-4a20-be2d-f701af21873c And we can verify that it has been removed and the other programs re-ordered: sudo ./target/debug/bpfctl list UUID Type Name Location Metadata 1ccc1376-60e8-4dc5-9079-6c32748fa1c4 xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 50, iface: vethb2795c7, position: 0, proceed_on: pass, dispatcher_return } b2f19b7b-4c71-4338-873e-914bd8fa44ba xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 150, iface: vethb2795c7, position: 1, proceed_on: pass, dispatcher_return } 6af7c28f-6a7f-46ee-bc98-2d92ed261369 xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 200, iface: vethb2795c7, position: 2, proceed_on: pass, dispatcher_return } When bpfd is stopped, all remaining programs will be unloaded automatically.","title":"Step 6: Delete a program"},{"location":"getting-started/tutorial/#step-7-clean-up","text":"To unwind all the changes, stop bpfd and then run the following script: sudo ./scripts/setup.sh uninstall WARNING: setup.sh uninstall cleans everything up, so /etc/bpfd/programs.d/ and /run/bpfd/bytecode/ are deleted. Save any changes or files that were created if needed.","title":"Step 7: Clean-up"},{"location":"getting-started/tutorial/#systemd-service","text":"To run bpfd as a systemd service, the binaries will be placed in a well known location ( /usr/sbin/. ) and a service configuration file will be added ( /usr/lib/systemd/system/bpfd.service ). When run as a systemd service, the set of linux capabilities are limited to only the needed set. If permission errors are encountered, see Linux Capabilities for help debugging.","title":"Systemd Service"},{"location":"getting-started/tutorial/#step-1","text":"Same as Step 1 above, build bpfd if needed: cd $HOME/src/bpfd/ cargo xtask build-ebpf --libbpf-dir $HOME/src/libbpf cargo build","title":"Step 1"},{"location":"getting-started/tutorial/#step-2-setup-bpfd-environment_1","text":"Run the following command to copy the bpfd and bpfctl binaries to /usr/sbin/ and set the user and user group for each, and copy a default bpfd.service file to /usr/lib/systemd/system/ . This option will also start the systemd service bpfd.service by default: sudo ./scripts/setup.sh install Then add usergroup bpfd to the desired user if not already run and logout/login to apply. Programs run by users which are members of the bpfd user group are able to access the mTLS certificates created by bpfd. Therefore, these programs can make bpfd requests without requiring sudo . For userspace programs accessing maps, the maps are owned by the bpfd user and bpfd user group. Programs run by users which are members of the bpfd user group are able to access the maps files without requiring sudo (specifically CAP_DAC_SEARCH or CAP_DAC_OVERIDE). sudo usermod -a -G bpfd $USER exit <LOGIN> NOTE: Prior to kernel 5.19 , all eBPF sys calls required CAP_BPF, which are used to access maps shared between the BFP program and the userspace program. So userspace programs that are accessing maps and running on kernels older than 5.19 will require either sudo or the CAP_BPF capability ( sudo /sbin/setcap cap_bpf=ep ./<USERSPACE-PROGRAM> ). To update the configuration settings associated with running bpfd as a service, edit the service configuration file: sudo vi /usr/lib/systemd/system/bpfd.service sudo systemctl daemon-reload If bpfd or bpfctl is rebuilt, the following command can be run to install the update binaries without tearing down the users and regenerating the certifications. The bpfd service will is automatically restarted. sudo ./scripts/setup.sh reinstall","title":"Step 2: Setup bpfd environment"},{"location":"getting-started/tutorial/#step-3-start-bpfd_1","text":"To manage bpfd as a systemd service, use systemctl . sudo ./scripts/setup.sh install will start the service, but the service can be manually stopped and started: sudo systemctl stop bpfd.service ... sudo systemctl start bpfd.service","title":"Step 3: Start bpfd"},{"location":"getting-started/tutorial/#step-4-6","text":"Same as above except sudo can be dropped from all the bpfctl commands and bpfctl is now in $PATH: bpfctl load-from-image --image-url quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 100 92e3e14c-0400-4a20-be2d-f701af21873c bpfctl list UUID Type Name Location Metadata 92e3e14c-0400-4a20-be2d-f701af21873c xdp pass image: { url: quay.io/bpfd-bytecode/xdp_pass:latest, pullpolicy: IfNotPresent } { priority: 100, iface: vethb2795c7, position: 0, proceed_on: pass, dispatcher_return } bpfctl unload 92e3e14c-0400-4a20-be2d-f701af21873c","title":"Step 4-6"},{"location":"getting-started/tutorial/#step-7-clean-up_1","text":"To unwind all the changes performed while running bpfd as a systemd service, run the following script. This command cleans up everything, including stopping the bpfd service if it is still running. sudo ./scripts/setup.sh uninstall WARNING: setup.sh uninstall cleans everything up, so /etc/bpfd/programs.d/ and /run/bpfd/bytecode/ are deleted. Save any changes or files that were created if needed.","title":"Step 7: Clean-up"},{"location":"getting-started/tutorial/#build-and-run-local-ebpf-programs","text":"In the examples above, all the eBPF programs were pulled from pre-built images. This tutorial uses examples from the xdp-tutorial . The pre-built container images can be found here: https://quay.io/organization/bpfd-bytecode To build these examples locally, check out the xdp-tutorial git repository and compile the examples. eBPF Bytecode Image Specifications describes how eBPF bytecode ispackaged in container images. To load these programs locally, use the bpfctl load-from-file command in place of the bpfctl load-from-image command. For example: sudo ./target/debug/bpfctl load-from-file --path /$HOME/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o --section-name \"xdp\" xdp --iface vethb2795c7 --priority 100","title":"Build and Run Local eBPF Programs"},{"location":"governance/CODE_OF_CONDUCT/","text":"Contributor Covenant Code of Conduct Our Pledge We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community. Our Standards Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Enforcement Responsibilities Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate. Scope This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement directly. Maintainers are identified in the MAINTAINERS.md file and their contact information is on their GitHub profile page. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident. Enforcement Guidelines Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct: 1. Correction Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested. 2. Warning Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban. 3. Temporary Ban Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban. 4. Permanent Ban Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html . Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq . Translations are available at https://www.contributor-covenant.org/translations .","title":"Code of Conduct"},{"location":"governance/CODE_OF_CONDUCT/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"governance/CODE_OF_CONDUCT/#our-pledge","text":"We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","title":"Our Pledge"},{"location":"governance/CODE_OF_CONDUCT/#our-standards","text":"Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"governance/CODE_OF_CONDUCT/#enforcement-responsibilities","text":"Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.","title":"Enforcement Responsibilities"},{"location":"governance/CODE_OF_CONDUCT/#scope","text":"This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.","title":"Scope"},{"location":"governance/CODE_OF_CONDUCT/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement directly. Maintainers are identified in the MAINTAINERS.md file and their contact information is on their GitHub profile page. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident.","title":"Enforcement"},{"location":"governance/CODE_OF_CONDUCT/#enforcement-guidelines","text":"Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:","title":"Enforcement Guidelines"},{"location":"governance/CODE_OF_CONDUCT/#1-correction","text":"Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.","title":"1. Correction"},{"location":"governance/CODE_OF_CONDUCT/#2-warning","text":"Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.","title":"2. Warning"},{"location":"governance/CODE_OF_CONDUCT/#3-temporary-ban","text":"Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.","title":"3. Temporary Ban"},{"location":"governance/CODE_OF_CONDUCT/#4-permanent-ban","text":"Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community.","title":"4. Permanent Ban"},{"location":"governance/CODE_OF_CONDUCT/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html . Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq . Translations are available at https://www.contributor-covenant.org/translations .","title":"Attribution"},{"location":"governance/CONTRIBUTING/","text":"Contributing Guide New Contributor Guide Ways to Contribute Find an Issue Ask for Help Pull Request Lifecycle Development Environment Setup Signoff Your Commits Pull Request Checklist Welcome! We are glad that you want to contribute to our project! \ud83d\udc96 As you get started, you are in the best position to give us feedback on areas of our project that we need help with including: Problems found during setting up a new developer environment Gaps in our Quickstart Guide or documentation Bugs in our automation scripts If anything doesn't make sense, or doesn't work when you run it, please open a bug report and let us know! Ways to Contribute We welcome many different types of contributions including: New features Builds, CI/CD Bug fixes Documentation Issue Triage Answering questions on Slack/Mailing List Web design Communications / Social Media / Blog Posts Release management Not everything happens through a GitHub pull request. Please come to our meetings or contact us and let's discuss how we can work together. Come to Meetings Absolutely everyone is welcome to come to any of our meetings. You never need an invite to join us. In fact, we want you to join us, even if you don\u2019t have anything you feel like you want to contribute. Just being there is enough! You can find out more about our meetings here . You don\u2019t have to turn on your video. The first time you come, introducing yourself is more than enough. Over time, we hope that you feel comfortable voicing your opinions, giving feedback on others\u2019 ideas, and even sharing your own ideas, and experiences. Find an Issue We have good first issues for new contributors and help wanted issues suitable for any contributor. good first issue has extra information to help you make your first contribution. help wanted are issues suitable for someone who isn't a core maintainer and is good to move onto after your first pull request. Sometimes there won\u2019t be any issues with these labels. That\u2019s ok! There is likely still something for you to work on. If you want to contribute but you don\u2019t know where to start or can't find a suitable issue, you can reach out to us on Slack and we will be happy to help. Once you see an issue that you'd like to work on, please post a comment saying that you want to work on it. Something like \"I want to work on this\" is fine. Ask for Help The best way to reach us with a question when contributing is to ask on: The original github issue Our Slack channel Pull Request Lifecycle Pull requests are managed by Mergify. Our process is currently as follows: When you open a PR a maintainer will automatically be assigned for review Make sure that your PR is passing CI - if you need help with failing checks please feel free to ask! Once it is passing all CI checks, a maintainer will review your PR and you may be asked to make changes. When you have received at least one approval from a maintainer, your PR will be merged automiatcally. In some cases, other changes may conflict with your PR. If this happens, you will get notified by a comment in the issue that your PR requires a rebase, and the needs-rebase label will be applied. Once a rebase has been performed, this label will be automatically removed. Development Environment Setup Instructions Signoff Your Commits DCO Licensing is important to open source projects. It provides some assurances that the software will continue to be available based under the terms that the author(s) desired. We require that contributors sign off on commits submitted to our project's repositories. The Developer Certificate of Origin (DCO) is a way to certify that you wrote and have the right to contribute the code you are submitting to the project. You sign-off by adding the following to your commit messages. Your sign-off must match the git user and email associated with the commit. This is my commit message Signed-off-by: Your Name <your.name@example.com> Git has a -s command line option to do this automatically: git commit -s -m 'This is my commit message' If you forgot to do this and have not yet pushed your changes to the remote repository, you can amend your commit with the sign-off by running git commit --amend -s Logical Grouping of Commits It is a recommended best practice to keep your changes as logically grouped as possible within individual commits. If while you're developing you prefer doing a number of commits that are \"checkpoints\" and don't represent a single logical change, please squash those together before asking for a review. When addressing review comments, please perform an interactive rebase and edit commits directly rather than adding new commits with messages like \"Fix review comments\". Commit message guidelines A good commit message should describe what changed and why. The first line should: contain a short description of the change (preferably 50 characters or less, and no more than 72 characters) be entirely in lowercase with the exception of proper nouns, acronyms, and the words that refer to code, like function/variable names be prefixed with the name of the sub crate being changed Examples: * bpfd: validate program section names * bpf: add dispatcher program test slot Keep the second line blank. Wrap all other lines at 72 columns (except for long URLs). If your patch fixes an open issue, you can add a reference to it at the end of the log. Use the Fixes: # prefix and the issue number. For other references use Refs: # . Refs may include multiple issues, separated by a comma. Examples: Fixes: #1337 Refs: #1234 Sample complete commit message: subcrate: explain the commit in one line Body of commit message is a few lines of text, explaining things in more detail, possibly giving some background about the issue being fixed, etc. The body of the commit message can be several paragraphs, and please do proper word-wrap and keep columns shorter than about 72 characters or so. That way, `git log` will show things nicely even when it is indented. Fixes: #1337 Refs: #453, #154 Pull Request Checklist When you submit your pull request, or you push new commits to it, our automated systems will run some checks on your new code. We require that your pull request passes these checks, but we also have more criteria than just that before we can accept and merge it. We recommend that you check the following things locally before you submit your code: That Rust code has been formatted with cargo +nightly fmt and that all clippy lints have been fixed - you can find failing lints with cargo +nightly clippy That Go code has been formatted and linted That unit tests are passing locally with cargo test That integration tests are passing locally cargo xtask integration-test","title":"Contributing"},{"location":"governance/CONTRIBUTING/#contributing-guide","text":"New Contributor Guide Ways to Contribute Find an Issue Ask for Help Pull Request Lifecycle Development Environment Setup Signoff Your Commits Pull Request Checklist Welcome! We are glad that you want to contribute to our project! \ud83d\udc96 As you get started, you are in the best position to give us feedback on areas of our project that we need help with including: Problems found during setting up a new developer environment Gaps in our Quickstart Guide or documentation Bugs in our automation scripts If anything doesn't make sense, or doesn't work when you run it, please open a bug report and let us know!","title":"Contributing Guide"},{"location":"governance/CONTRIBUTING/#ways-to-contribute","text":"We welcome many different types of contributions including: New features Builds, CI/CD Bug fixes Documentation Issue Triage Answering questions on Slack/Mailing List Web design Communications / Social Media / Blog Posts Release management Not everything happens through a GitHub pull request. Please come to our meetings or contact us and let's discuss how we can work together.","title":"Ways to Contribute"},{"location":"governance/CONTRIBUTING/#come-to-meetings","text":"Absolutely everyone is welcome to come to any of our meetings. You never need an invite to join us. In fact, we want you to join us, even if you don\u2019t have anything you feel like you want to contribute. Just being there is enough! You can find out more about our meetings here . You don\u2019t have to turn on your video. The first time you come, introducing yourself is more than enough. Over time, we hope that you feel comfortable voicing your opinions, giving feedback on others\u2019 ideas, and even sharing your own ideas, and experiences.","title":"Come to Meetings"},{"location":"governance/CONTRIBUTING/#find-an-issue","text":"We have good first issues for new contributors and help wanted issues suitable for any contributor. good first issue has extra information to help you make your first contribution. help wanted are issues suitable for someone who isn't a core maintainer and is good to move onto after your first pull request. Sometimes there won\u2019t be any issues with these labels. That\u2019s ok! There is likely still something for you to work on. If you want to contribute but you don\u2019t know where to start or can't find a suitable issue, you can reach out to us on Slack and we will be happy to help. Once you see an issue that you'd like to work on, please post a comment saying that you want to work on it. Something like \"I want to work on this\" is fine.","title":"Find an Issue"},{"location":"governance/CONTRIBUTING/#ask-for-help","text":"The best way to reach us with a question when contributing is to ask on: The original github issue Our Slack channel","title":"Ask for Help"},{"location":"governance/CONTRIBUTING/#pull-request-lifecycle","text":"Pull requests are managed by Mergify. Our process is currently as follows: When you open a PR a maintainer will automatically be assigned for review Make sure that your PR is passing CI - if you need help with failing checks please feel free to ask! Once it is passing all CI checks, a maintainer will review your PR and you may be asked to make changes. When you have received at least one approval from a maintainer, your PR will be merged automiatcally. In some cases, other changes may conflict with your PR. If this happens, you will get notified by a comment in the issue that your PR requires a rebase, and the needs-rebase label will be applied. Once a rebase has been performed, this label will be automatically removed.","title":"Pull Request Lifecycle"},{"location":"governance/CONTRIBUTING/#development-environment-setup","text":"Instructions","title":"Development Environment Setup"},{"location":"governance/CONTRIBUTING/#signoff-your-commits","text":"","title":"Signoff Your Commits"},{"location":"governance/CONTRIBUTING/#dco","text":"Licensing is important to open source projects. It provides some assurances that the software will continue to be available based under the terms that the author(s) desired. We require that contributors sign off on commits submitted to our project's repositories. The Developer Certificate of Origin (DCO) is a way to certify that you wrote and have the right to contribute the code you are submitting to the project. You sign-off by adding the following to your commit messages. Your sign-off must match the git user and email associated with the commit. This is my commit message Signed-off-by: Your Name <your.name@example.com> Git has a -s command line option to do this automatically: git commit -s -m 'This is my commit message' If you forgot to do this and have not yet pushed your changes to the remote repository, you can amend your commit with the sign-off by running git commit --amend -s","title":"DCO"},{"location":"governance/CONTRIBUTING/#logical-grouping-of-commits","text":"It is a recommended best practice to keep your changes as logically grouped as possible within individual commits. If while you're developing you prefer doing a number of commits that are \"checkpoints\" and don't represent a single logical change, please squash those together before asking for a review. When addressing review comments, please perform an interactive rebase and edit commits directly rather than adding new commits with messages like \"Fix review comments\".","title":"Logical Grouping of Commits"},{"location":"governance/CONTRIBUTING/#commit-message-guidelines","text":"A good commit message should describe what changed and why. The first line should: contain a short description of the change (preferably 50 characters or less, and no more than 72 characters) be entirely in lowercase with the exception of proper nouns, acronyms, and the words that refer to code, like function/variable names be prefixed with the name of the sub crate being changed Examples: * bpfd: validate program section names * bpf: add dispatcher program test slot Keep the second line blank. Wrap all other lines at 72 columns (except for long URLs). If your patch fixes an open issue, you can add a reference to it at the end of the log. Use the Fixes: # prefix and the issue number. For other references use Refs: # . Refs may include multiple issues, separated by a comma. Examples: Fixes: #1337 Refs: #1234 Sample complete commit message: subcrate: explain the commit in one line Body of commit message is a few lines of text, explaining things in more detail, possibly giving some background about the issue being fixed, etc. The body of the commit message can be several paragraphs, and please do proper word-wrap and keep columns shorter than about 72 characters or so. That way, `git log` will show things nicely even when it is indented. Fixes: #1337 Refs: #453, #154","title":"Commit message guidelines"},{"location":"governance/CONTRIBUTING/#pull-request-checklist","text":"When you submit your pull request, or you push new commits to it, our automated systems will run some checks on your new code. We require that your pull request passes these checks, but we also have more criteria than just that before we can accept and merge it. We recommend that you check the following things locally before you submit your code: That Rust code has been formatted with cargo +nightly fmt and that all clippy lints have been fixed - you can find failing lints with cargo +nightly clippy That Go code has been formatted and linted That unit tests are passing locally with cargo test That integration tests are passing locally cargo xtask integration-test","title":"Pull Request Checklist"},{"location":"governance/GOVERNANCE/","text":"bpfd Project Governance The bpfd project is dedicated to creating an easy way to run eBPF programs on a single host and in clusters. This governance explains how the project is run. Values Maintainers Becoming a Maintainer Meetings Code of Conduct Enforcement Security Response Team Voting Modifications Values The bpfd project and its leadership embrace the following values: Openness: Communication and decision-making happens in the open and is discoverable for future reference. As much as possible, all discussions and work take place in public forums and open repositories. Fairness: All stakeholders have the opportunity to provide feedback and submit contributions, which will be considered on their merits. Community over Product or Company: Sustaining and growing our community takes priority over shipping code or sponsors' organizational goals. Each contributor participates in the project as an individual. Inclusivity: We innovate through different perspectives and skill sets, which can only be accomplished in a welcoming and respectful environment. Participation: Responsibilities within the project are earned through participation, and there is a clear path up the contributor ladder into leadership positions. Maintainers bpfd Maintainers have write access to the project GitHub repository . They can merge their patches or patches from others. The list of current maintainers can be found at MAINTAINERS.md . Maintainers collectively manage the project's resources and contributors. This privilege is granted with some expectation of responsibility: maintainers are people who care about the bpfd project and want to help it grow and improve. A maintainer is not just someone who can make changes, but someone who has demonstrated their ability to collaborate with the team, get the most knowledgeable people to review code and docs, contribute high-quality code, and follow through to fix issues (in code or tests). A maintainer is a contributor to the project's success and a citizen helping the project succeed. The collective team of all Maintainers is known as the Maintainer Council, which is the governing body for the project. Becoming a Maintainer To become a Maintainer you need to demonstrate the following: commitment to the project: participate in discussions, contributions, code and documentation reviews, for 6 months or more, perform reviews for 10 non-trivial pull requests, contribute 10 non-trivial pull requests and have them merged, ability to write quality code and/or documentation, ability to collaborate with the team, understanding of how the team works (policies, processes for testing and code review, etc), understanding of the project's code base and coding and documentation style. A new Maintainer must be proposed by an existing maintainer by opening a Pull Request on GitHub to update the MAINTAINERS.md file. A simple majority vote of existing Maintainers approves the application. Maintainer nominations will be evaluated without prejudice to employers or demographics. Maintainers who are selected will be granted the necessary GitHub rights. Removing a Maintainer Maintainers may resign at any time if they feel that they will not be able to continue fulfilling their project duties. Maintainers may also be removed after being inactive, failing to fulfill their Maintainer responsibilities, violating the Code of Conduct, or for other reasons. Inactivity is defined as a period of very low or no activity in the project for a year or more, with no definite schedule to return to full Maintainer activity. A Maintainer may be removed at any time by a 2/3 vote of the remaining maintainers. Depending on the reason for removal, a Maintainer may be converted to Emeritus status. Emeritus Maintainers will still be consulted on some project matters and can be rapidly returned to Maintainer status if their availability changes. Meetings Time zones permitting, Maintainers are expected to participate in the public developer meeting, detailed in the meetings document . Maintainers will also have closed meetings to discuss security reports or Code of Conduct violations. Such meetings should be scheduled by any Maintainer on receipt of a security issue or CoC report. All current Maintainers must be invited to such closed meetings, except for any Maintainer who is accused of a CoC violation. Code of Conduct Code of Conduct violations by community members will be discussed and resolved on the private maintainer Slack channel. Security Response Team The Maintainers will appoint a Security Response Team to handle security reports. This committee may simply consist of the Maintainer Council themselves. If this responsibility is delegated, the Maintainers will appoint a team of at least two contributors to handle it. The Maintainers will review who is assigned to this at least once a year. The Security Response Team is responsible for handling all reports of security holes and breaches according to the security policy . Voting While most business in bpfd is conducted by \" lazy consensus \", periodically the Maintainers may need to vote on specific actions or changes. A vote can be taken on the private developer slack channel for security or conduct matters. Votes may also be taken at the developer meeting . Any Maintainer may demand a vote be taken. Most votes require a simple majority of all Maintainers to succeed, except where otherwise noted. Two-thirds majority votes mean at least two-thirds of all existing maintainers. Modifying this Charter Changes to this Governance and its supporting documents may be approved by a 2/3 vote of the Maintainers.","title":"Governance"},{"location":"governance/GOVERNANCE/#bpfd-project-governance","text":"The bpfd project is dedicated to creating an easy way to run eBPF programs on a single host and in clusters. This governance explains how the project is run. Values Maintainers Becoming a Maintainer Meetings Code of Conduct Enforcement Security Response Team Voting Modifications","title":"bpfd Project Governance"},{"location":"governance/GOVERNANCE/#values","text":"The bpfd project and its leadership embrace the following values: Openness: Communication and decision-making happens in the open and is discoverable for future reference. As much as possible, all discussions and work take place in public forums and open repositories. Fairness: All stakeholders have the opportunity to provide feedback and submit contributions, which will be considered on their merits. Community over Product or Company: Sustaining and growing our community takes priority over shipping code or sponsors' organizational goals. Each contributor participates in the project as an individual. Inclusivity: We innovate through different perspectives and skill sets, which can only be accomplished in a welcoming and respectful environment. Participation: Responsibilities within the project are earned through participation, and there is a clear path up the contributor ladder into leadership positions.","title":"Values"},{"location":"governance/GOVERNANCE/#maintainers","text":"bpfd Maintainers have write access to the project GitHub repository . They can merge their patches or patches from others. The list of current maintainers can be found at MAINTAINERS.md . Maintainers collectively manage the project's resources and contributors. This privilege is granted with some expectation of responsibility: maintainers are people who care about the bpfd project and want to help it grow and improve. A maintainer is not just someone who can make changes, but someone who has demonstrated their ability to collaborate with the team, get the most knowledgeable people to review code and docs, contribute high-quality code, and follow through to fix issues (in code or tests). A maintainer is a contributor to the project's success and a citizen helping the project succeed. The collective team of all Maintainers is known as the Maintainer Council, which is the governing body for the project.","title":"Maintainers"},{"location":"governance/GOVERNANCE/#becoming-a-maintainer","text":"To become a Maintainer you need to demonstrate the following: commitment to the project: participate in discussions, contributions, code and documentation reviews, for 6 months or more, perform reviews for 10 non-trivial pull requests, contribute 10 non-trivial pull requests and have them merged, ability to write quality code and/or documentation, ability to collaborate with the team, understanding of how the team works (policies, processes for testing and code review, etc), understanding of the project's code base and coding and documentation style. A new Maintainer must be proposed by an existing maintainer by opening a Pull Request on GitHub to update the MAINTAINERS.md file. A simple majority vote of existing Maintainers approves the application. Maintainer nominations will be evaluated without prejudice to employers or demographics. Maintainers who are selected will be granted the necessary GitHub rights.","title":"Becoming a Maintainer"},{"location":"governance/GOVERNANCE/#removing-a-maintainer","text":"Maintainers may resign at any time if they feel that they will not be able to continue fulfilling their project duties. Maintainers may also be removed after being inactive, failing to fulfill their Maintainer responsibilities, violating the Code of Conduct, or for other reasons. Inactivity is defined as a period of very low or no activity in the project for a year or more, with no definite schedule to return to full Maintainer activity. A Maintainer may be removed at any time by a 2/3 vote of the remaining maintainers. Depending on the reason for removal, a Maintainer may be converted to Emeritus status. Emeritus Maintainers will still be consulted on some project matters and can be rapidly returned to Maintainer status if their availability changes.","title":"Removing a Maintainer"},{"location":"governance/GOVERNANCE/#meetings","text":"Time zones permitting, Maintainers are expected to participate in the public developer meeting, detailed in the meetings document . Maintainers will also have closed meetings to discuss security reports or Code of Conduct violations. Such meetings should be scheduled by any Maintainer on receipt of a security issue or CoC report. All current Maintainers must be invited to such closed meetings, except for any Maintainer who is accused of a CoC violation.","title":"Meetings"},{"location":"governance/GOVERNANCE/#code-of-conduct","text":"Code of Conduct violations by community members will be discussed and resolved on the private maintainer Slack channel.","title":"Code of Conduct"},{"location":"governance/GOVERNANCE/#security-response-team","text":"The Maintainers will appoint a Security Response Team to handle security reports. This committee may simply consist of the Maintainer Council themselves. If this responsibility is delegated, the Maintainers will appoint a team of at least two contributors to handle it. The Maintainers will review who is assigned to this at least once a year. The Security Response Team is responsible for handling all reports of security holes and breaches according to the security policy .","title":"Security Response Team"},{"location":"governance/GOVERNANCE/#voting","text":"While most business in bpfd is conducted by \" lazy consensus \", periodically the Maintainers may need to vote on specific actions or changes. A vote can be taken on the private developer slack channel for security or conduct matters. Votes may also be taken at the developer meeting . Any Maintainer may demand a vote be taken. Most votes require a simple majority of all Maintainers to succeed, except where otherwise noted. Two-thirds majority votes mean at least two-thirds of all existing maintainers.","title":"Voting"},{"location":"governance/GOVERNANCE/#modifying-this-charter","text":"Changes to this Governance and its supporting documents may be approved by a 2/3 vote of the Maintainers.","title":"Modifying this Charter"},{"location":"governance/MAINTAINERS/","text":"Maintainers See CONTRIBUTING.md for general contribution guidelines. See GOVERNANCE.md for governance guidelines and maintainer responsibilities. See CODEOWNERS for a detailed list of owners for the various source directories. Name Employer Responsibilities Dave Tucker Red Hat Catch all Andrew Stoycos Red Hat bpfd-operator, bpfd-agent Andre Fredette Red Hat All things tc-bpf Billy McFall Red Hat All things systemd","title":"Maintainers"},{"location":"governance/MAINTAINERS/#maintainers","text":"See CONTRIBUTING.md for general contribution guidelines. See GOVERNANCE.md for governance guidelines and maintainer responsibilities. See CODEOWNERS for a detailed list of owners for the various source directories. Name Employer Responsibilities Dave Tucker Red Hat Catch all Andrew Stoycos Red Hat bpfd-operator, bpfd-agent Andre Fredette Red Hat All things tc-bpf Billy McFall Red Hat All things systemd","title":"Maintainers"},{"location":"governance/MEETINGS/","text":"bpfd Community Meetings Meeting time We meet every Thursday at 10:00 AM Eastern Time. The meetings last up to 1 hour. Meeting location Video call link: https://meet.google.com/ggz-zkmp-pxx Or dial: (US) +1 98ttp4-221-0859 PIN: 613 588 790# More phone numbers: https://tel.meet/ggz-zkmp-pxx?pin=3270510926446 Meeting agenda and minutes Meeting agenda","title":"Meetings"},{"location":"governance/MEETINGS/#bpfd-community-meetings","text":"","title":"bpfd Community Meetings"},{"location":"governance/MEETINGS/#meeting-time","text":"We meet every Thursday at 10:00 AM Eastern Time. The meetings last up to 1 hour.","title":"Meeting time"},{"location":"governance/MEETINGS/#meeting-location","text":"Video call link: https://meet.google.com/ggz-zkmp-pxx Or dial: (US) +1 98ttp4-221-0859 PIN: 613 588 790# More phone numbers: https://tel.meet/ggz-zkmp-pxx?pin=3270510926446","title":"Meeting location"},{"location":"governance/MEETINGS/#meeting-agenda-and-minutes","text":"Meeting agenda","title":"Meeting agenda and minutes"},{"location":"governance/REVIEWING/","text":"Reviewing Guide This document covers who may review pull requests for this project, and guides how to perform code reviews that meet our community standards and code of conduct. All reviewers must read this document and agree to follow the project review guidelines. Reviewers who do not follow these guidelines may have their privileges revoked. The Reviewer Role Only maintainers are REQUIRED to review pull requests. Other contributors may opt to review pull requests, but any LGTM from a non-maintainer won't count towards the required number of Approved Reviews in the Mergify policy. Values All reviewers must abide by the Code of Conduct and are also protected by it. A reviewer should not tolerate poor behavior and is encouraged to report any behavior that violates the Code of Conduct. All of our values listed above are distilled from our Code of Conduct. Below are concrete examples of how it applies to code review specifically: Inclusion Be welcoming and inclusive. You should proactively ensure that the author is successful. While any particular pull request may not ultimately be merged, overall we want people to have a great experience and be willing to contribute again. Answer the questions they didn't know to ask or offer concrete help when they appear stuck. Sustainability Avoid burnout by enforcing healthy boundaries. Here are some examples of how a reviewer is encouraged to act to take care of themselves: Authors should meet baseline expectations when submitting a pull request, such as writing tests. If your availability changes, you can step down from a pull request and have someone else assigned. If interactions with an author are not following the code of conduct, close the PR and raise it with your Code of Conduct committee or point of contact. It's not your job to coax people into behaving. Trust Be trustworthy. During a review, your actions both build and help maintain the trust that the community has placed in this project. Below are examples of ways that we build trust: Transparency - If a pull request won't be merged, clearly say why and close it. If a pull request won't be reviewed for a while, let the author know so they can set expectations and understand why it's blocked. Integrity - Put the project's best interests ahead of personal relationships or company affiliations when deciding if a change should be merged. Stability - Only merge when the change won't negatively impact project stability. It can be tempting to merge a pull request that doesn't meet our quality standards, for example when the review has been delayed, or because we are trying to deliver new features quickly, but regressions can significantly hurt trust in our project. Process Reviewers are automatically assigned based on the CODEOWNERS file. Reviewers should wait for automated checks to pass before reviewing At least 1 approved review is required from a maintainer before a pull request can be merged All CI checks must pass If a PR is stuck for some reason it is down to the reviewer to determine the best course of action: PRs may be closed if they are no longer relevant A maintainer may choose to carry a PR forward on their own, but they should ALWAYS include the original author's commits A maintainer may choose to open additional PRs to help lay a foundation on which the stuck PR can be unstuck. They may either rebase the stuck PR themselves or leave this to the author Maintainers should not merge their pull requests without a review Maintainers should let the Mergify bot merge PRs and not merge PRs directly In times of need, i.e. to fix pressing security issues, the Maintainers may, at their discretion, merge PRs without review. They should at least add a comment to the PR explaining why they did so. Checklist Below are a set of common questions that apply to all pull requests: [ ] Is this PR targeting the correct branch? [ ] Does the commit message provide an adequate description of the change? [ ] Does the affected code have corresponding tests? [ ] Are the changes documented, not just with inline documentation, but also with conceptual documentation such as an overview of a new feature, or task-based documentation like a tutorial? Consider if this change should be announced on your project blog. [ ] Does this introduce breaking changes that would require an announcement or bumping of the major version? [ ] Does this PR introduce any new dependencies? Reading List Reviewers are encouraged to read the following articles for help with common reviewer tasks: The Art of Closing: How to close an unfinished or rejected pull request Kindness and Code Reviews: Improving the Way We Give Feedback Code Review Guidelines for Humans: Examples of good and back feedback","title":"Reviewing Guide"},{"location":"governance/REVIEWING/#reviewing-guide","text":"This document covers who may review pull requests for this project, and guides how to perform code reviews that meet our community standards and code of conduct. All reviewers must read this document and agree to follow the project review guidelines. Reviewers who do not follow these guidelines may have their privileges revoked.","title":"Reviewing Guide"},{"location":"governance/REVIEWING/#the-reviewer-role","text":"Only maintainers are REQUIRED to review pull requests. Other contributors may opt to review pull requests, but any LGTM from a non-maintainer won't count towards the required number of Approved Reviews in the Mergify policy.","title":"The Reviewer Role"},{"location":"governance/REVIEWING/#values","text":"All reviewers must abide by the Code of Conduct and are also protected by it. A reviewer should not tolerate poor behavior and is encouraged to report any behavior that violates the Code of Conduct. All of our values listed above are distilled from our Code of Conduct. Below are concrete examples of how it applies to code review specifically:","title":"Values"},{"location":"governance/REVIEWING/#inclusion","text":"Be welcoming and inclusive. You should proactively ensure that the author is successful. While any particular pull request may not ultimately be merged, overall we want people to have a great experience and be willing to contribute again. Answer the questions they didn't know to ask or offer concrete help when they appear stuck.","title":"Inclusion"},{"location":"governance/REVIEWING/#sustainability","text":"Avoid burnout by enforcing healthy boundaries. Here are some examples of how a reviewer is encouraged to act to take care of themselves: Authors should meet baseline expectations when submitting a pull request, such as writing tests. If your availability changes, you can step down from a pull request and have someone else assigned. If interactions with an author are not following the code of conduct, close the PR and raise it with your Code of Conduct committee or point of contact. It's not your job to coax people into behaving.","title":"Sustainability"},{"location":"governance/REVIEWING/#trust","text":"Be trustworthy. During a review, your actions both build and help maintain the trust that the community has placed in this project. Below are examples of ways that we build trust: Transparency - If a pull request won't be merged, clearly say why and close it. If a pull request won't be reviewed for a while, let the author know so they can set expectations and understand why it's blocked. Integrity - Put the project's best interests ahead of personal relationships or company affiliations when deciding if a change should be merged. Stability - Only merge when the change won't negatively impact project stability. It can be tempting to merge a pull request that doesn't meet our quality standards, for example when the review has been delayed, or because we are trying to deliver new features quickly, but regressions can significantly hurt trust in our project.","title":"Trust"},{"location":"governance/REVIEWING/#process","text":"Reviewers are automatically assigned based on the CODEOWNERS file. Reviewers should wait for automated checks to pass before reviewing At least 1 approved review is required from a maintainer before a pull request can be merged All CI checks must pass If a PR is stuck for some reason it is down to the reviewer to determine the best course of action: PRs may be closed if they are no longer relevant A maintainer may choose to carry a PR forward on their own, but they should ALWAYS include the original author's commits A maintainer may choose to open additional PRs to help lay a foundation on which the stuck PR can be unstuck. They may either rebase the stuck PR themselves or leave this to the author Maintainers should not merge their pull requests without a review Maintainers should let the Mergify bot merge PRs and not merge PRs directly In times of need, i.e. to fix pressing security issues, the Maintainers may, at their discretion, merge PRs without review. They should at least add a comment to the PR explaining why they did so.","title":"Process"},{"location":"governance/REVIEWING/#checklist","text":"Below are a set of common questions that apply to all pull requests: [ ] Is this PR targeting the correct branch? [ ] Does the commit message provide an adequate description of the change? [ ] Does the affected code have corresponding tests? [ ] Are the changes documented, not just with inline documentation, but also with conceptual documentation such as an overview of a new feature, or task-based documentation like a tutorial? Consider if this change should be announced on your project blog. [ ] Does this introduce breaking changes that would require an announcement or bumping of the major version? [ ] Does this PR introduce any new dependencies?","title":"Checklist"},{"location":"governance/REVIEWING/#reading-list","text":"Reviewers are encouraged to read the following articles for help with common reviewer tasks: The Art of Closing: How to close an unfinished or rejected pull request Kindness and Code Reviews: Improving the Way We Give Feedback Code Review Guidelines for Humans: Examples of good and back feedback","title":"Reading List"},{"location":"governance/SECURITY/","text":"Security Policy Supported Versions No released versions of bpfd, bpfctl, bpfd-agent or bpfd-operator will receive regular security updates until a mainline release has been performed. A reported and fixed vulnerability will be included in the next minor release, which depending on the severity of the vulnerability may be immediate. Reporting a Vulnerability To report a vulnerability, please use the Private Vulnerability Reporting Feature on GitHub. We will endevour to respond within 48hrs of reporting. If a vulnerability is reported but considered low priority it may be converted into an issue and handled on the public issue tracker. Should a vulnerability be considered severe we will endeavour to patch it within 48hrs of acceptance, and may ask for you to collaborate with us on a temporary private fork of the repository.","title":"Security"},{"location":"governance/SECURITY/#security-policy","text":"","title":"Security Policy"},{"location":"governance/SECURITY/#supported-versions","text":"No released versions of bpfd, bpfctl, bpfd-agent or bpfd-operator will receive regular security updates until a mainline release has been performed. A reported and fixed vulnerability will be included in the next minor release, which depending on the severity of the vulnerability may be immediate.","title":"Supported Versions"},{"location":"governance/SECURITY/#reporting-a-vulnerability","text":"To report a vulnerability, please use the Private Vulnerability Reporting Feature on GitHub. We will endevour to respond within 48hrs of reporting. If a vulnerability is reported but considered low priority it may be converted into an issue and handled on the public issue tracker. Should a vulnerability be considered severe we will endeavour to patch it within 48hrs of acceptance, and may ask for you to collaborate with us on a temporary private fork of the repository.","title":"Reporting a Vulnerability"}]}